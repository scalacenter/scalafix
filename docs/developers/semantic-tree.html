<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>SemanticTree · Scalafix</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="`SemanticTree` is a sealed data structure that encodes tree nodes that are"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="SemanticTree · Scalafix"/><meta property="og:type" content="website"/><meta property="og:url" content="https://scalacenter.github.io//scalafix/index.html"/><meta property="og:description" content="`SemanticTree` is a sealed data structure that encodes tree nodes that are"/><meta property="og:image" content="https://scalacenter.github.io//scalafix/img/scalacenter2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://scalacenter.github.io//scalafix/img/scalacenter2x.png"/><link rel="shortcut icon" href="/scalafix/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><link rel="stylesheet" href="/scalafix/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/scalafix/"><img class="logo" src="/scalafix/img/scalacenter2x.png" alt="Scalafix"/><h2 class="headerTitleWithLogo">Scalafix</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/scalafix/docs/users/installation.html" target="_self">User guide</a></li><li class="siteNavGroupActive"><a href="/scalafix/docs/developers/setup.html" target="_self">Developer guide</a></li><li class=""><a href="https://github.com/scalacenter/scalafix" target="_blank">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Implementing rules</h3><ul><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/setup.html">Setup</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/before-you-begin.html">Before you write code</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/tutorial.html">Tutorial</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API Reference</h3><ul><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/api.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/patch.html">Patch</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/symbol-matcher.html">SymbolMatcher</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/symbol-information.html">SymbolInformation</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/semantic-type.html">SemanticType</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/scalafix/docs/developers/semantic-tree.html">SemanticTree</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Contributing</h3><ul><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/contributing.html">Guide</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docMainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/scalacenter/scalafix/edit/master/docs/developers/semantic-tree.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">SemanticTree</h1></header><article><div><span><p><code>SemanticTree</code> is a sealed data structure that encodes tree nodes that are
generated by the compiler from inferred type parameters, implicit arguments,
implicit conversions, inferred <code>.apply</code> and for-comprehensions.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemanticTree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Serializable</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span></span>: <span class="hljs-type">String</span> = <span class="hljs-type">Pretty</span>.pretty(<span class="hljs-keyword">this</span>).render(<span class="hljs-number">80</span>)
  <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span></span>(width: <span class="hljs-type">Int</span>): <span class="hljs-type">String</span> = <span class="hljs-type">Pretty</span>.pretty(<span class="hljs-keyword">this</span>).render(width)
  <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isEmpty</span></span>: <span class="hljs-type">Boolean</span> = <span class="hljs-keyword">this</span> == <span class="hljs-type">NoTree</span>
  <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nonEmpty</span></span>: <span class="hljs-type">Boolean</span> = !isEmpty
}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdTree</span>(<span class="hljs-params">info: <span class="hljs-type">SymbolInformation</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span> </span>{ <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">symbol</span></span>: <span class="hljs-type">Symbol</span> = info.symbol }
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectTree</span>(<span class="hljs-params">qualifier: <span class="hljs-type">SemanticTree</span>, id: <span class="hljs-type">IdTree</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplyTree</span>(<span class="hljs-params">function: <span class="hljs-type">SemanticTree</span>, arguments: <span class="hljs-type">List</span>[<span class="hljs-type">SemanticTree</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeApplyTree</span>(<span class="hljs-params">function: <span class="hljs-type">SemanticTree</span>, typeArguments: <span class="hljs-type">List</span>[<span class="hljs-type">SemanticType</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionTree</span>(<span class="hljs-params">parameters: <span class="hljs-type">List</span>[<span class="hljs-type">IdTree</span>], body: <span class="hljs-type">SemanticTree</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiteralTree</span>(<span class="hljs-params">constant: <span class="hljs-type">Constant</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacroExpansionTree</span>(<span class="hljs-params">beforeExpansion: <span class="hljs-type">SemanticTree</span>, tpe: <span class="hljs-type">SemanticType</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OriginalSubTree</span>(<span class="hljs-params">tree: scala.meta.<span class="hljs-type">Tree</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OriginalTree</span>(<span class="hljs-params">tree: scala.meta.<span class="hljs-type">Tree</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NoTree</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SemanticTree</span></span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="cookbook"></a><a href="#cookbook" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cookbook</h2>
<p>All code examples in this document assume you have the following imports in
scope</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scalafix.v1._
<span class="hljs-keyword">import</span> scala.meta._
</code></pre>
<p>The variable <code>doc</code> in the code examples is an implicit instance of
<code>scalafix.v1.SemanticDoc</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="look-up-inferred-type-parameter"></a><a href="#look-up-inferred-type-parameter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Look up inferred type parameter</h3>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Option</span>.apply(<span class="hljs-number">1</span>) <span class="hljs-comment">// inferred type parameter</span>
</code></pre>
<p>Use <code>Tree.synthetic</code> on the qualifier <code>Option.apply</code> to get the inferred type
parameters</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-comment">// Option.apply</span>
  <span class="hljs-keyword">case</span> option @ <span class="hljs-type">Term</span>.<span class="hljs-type">Select</span>(<span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"Option"</span>), <span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"apply"</span>)) =&gt;
    println(<span class="hljs-string">"synthetic = "</span> + option.synthetic)
    println(<span class="hljs-string">"structure = "</span> + option.synthetic.structure)
}
<span class="hljs-comment">// synthetic = Some(*[Int])</span>
<span class="hljs-comment">// structure = Some(TypeApplyTree(</span>
<span class="hljs-comment">//   OriginalTree(Term.Select(Term.Name("Option"), Term.Name("apply"))),</span>
<span class="hljs-comment">//   List(TypeRef(NoType, Symbol("scala/Int#"), List()))</span>
<span class="hljs-comment">// ))</span>
</code></pre>
<p>The asterisk <code>*</code> represents an <code>OriginalTree</code> node that matches the enclosing
non-synthetic tree, which is <code>List</code> in this example.</p>
<p>The <code>.synthetic</code> method is only available on <code>Term</code> nodes, using the method on
other tree nodes such as types results in compilation error</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> app @ <span class="hljs-type">Type</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"App"</span>) =&gt;
    println(<span class="hljs-string">".synthetic = "</span> + app.synthetic)
}
<span class="hljs-comment">// value synthetic is not a member of scala.meta.Type.Name</span>
<span class="hljs-comment">//     println(".synthetic = " + app.synthetic)</span>
<span class="hljs-comment">//                                   ^</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="look-up-symbol-of-semantic-tree"></a><a href="#look-up-symbol-of-semantic-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Look up symbol of semantic tree</h3>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> add: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span> = _ + <span class="hljs-number">1</span>
add(<span class="hljs-number">2</span>)         <span class="hljs-comment">// inferred: add.apply(2)</span>
<span class="hljs-type">Option</span>[<span class="hljs-type">Int</span>](<span class="hljs-number">2</span>) <span class="hljs-comment">// inferred: Option.apply[Int](2)</span>
</code></pre>
<p>Use <code>Tree.synthetic</code> in combination with <code>SemanticTree.symbol</code> to get the symbol
of those inferred <code>.apply</code> method calls.</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Term</span>.<span class="hljs-type">Apply</span>(add @ <span class="hljs-string">q"add"</span>, <span class="hljs-type">List</span>(<span class="hljs-string">q"2"</span>)) =&gt;
    println(<span class="hljs-string">"add(2)"</span>)
    println(<span class="hljs-string">"synthetic = "</span> + add.synthetic)
    println(<span class="hljs-string">"symbol    = "</span> + add.synthetic.flatMap(_.symbol).structure)
    println(<span class="hljs-string">"structure = "</span> + add.synthetic.structure)
  <span class="hljs-keyword">case</span> <span class="hljs-type">Term</span>.<span class="hljs-type">ApplyType</span>(option @ <span class="hljs-string">q"Option"</span>, <span class="hljs-type">List</span>(<span class="hljs-string">t"Int"</span>)) =&gt;
    println(<span class="hljs-string">"Option[Int]"</span>)
    println(<span class="hljs-string">"synthetic = "</span> + option.synthetic)
    println(<span class="hljs-string">"symbol    = "</span> + option.synthetic.flatMap(_.symbol).structure)
    println(<span class="hljs-string">"structure = "</span> + option.synthetic.structure)
}
<span class="hljs-comment">// add(2)</span>
<span class="hljs-comment">// synthetic = Some(*.apply)</span>
<span class="hljs-comment">// symbol    = Some(Symbol("scala/Function1#apply()."))</span>
<span class="hljs-comment">// structure = Some(SelectTree(</span>
<span class="hljs-comment">//   OriginalTree(Term.Name("add")),</span>
<span class="hljs-comment">//   IdTree(SymbolInformation(scala/Function1#apply(). =&gt; abstract method apply(v1: T1): R))</span>
<span class="hljs-comment">// ))</span>
<span class="hljs-comment">// Option[Int]</span>
<span class="hljs-comment">// synthetic = Some(*.apply)</span>
<span class="hljs-comment">// symbol    = Some(Symbol("scala/Option.apply()."))</span>
<span class="hljs-comment">// structure = Some(SelectTree(</span>
<span class="hljs-comment">//   OriginalTree(Term.Name("Option")),</span>
<span class="hljs-comment">//   IdTree(SymbolInformation(scala/Option.apply(). =&gt; method apply[A](x: A): Option[A]))</span>
<span class="hljs-comment">// ))</span>
</code></pre>
<p>The <code>.symbol</code> method returns nothing for the following semantic trees</p>
<ul>
<li><code>MacroExpansionTree</code></li>
<li><code>LiteralTree</code></li>
<li><code>FunctionTree</code></li>
<li><code>NoTree</code></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="look-up-implicit-argument"></a><a href="#look-up-implicit-argument" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Look up implicit argument</h3>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">ExecutionContext</span>.<span class="hljs-type">Implicits</span>.global
<span class="hljs-keyword">import</span> scala.concurrent.<span class="hljs-type">Future</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(<span class="hljs-keyword">implicit</span> message: <span class="hljs-type">String</span>) = println(message)
<span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> message = <span class="hljs-string">"hello world"</span>

<span class="hljs-type">Future</span>.apply[<span class="hljs-type">Int</span>](<span class="hljs-number">3</span>) <span class="hljs-comment">// implicit argument: global</span>
<span class="hljs-type">Main</span>.run             <span class="hljs-comment">// implicit argument: message</span>
</code></pre>
<p>Use <code>Tree.synthetic</code> to look up an implicit argument for any <code>Term</code> node.</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> term: <span class="hljs-type">Term</span> <span class="hljs-keyword">if</span> term.synthetic.isDefined =&gt;
    println(<span class="hljs-string">"term      = "</span> + term.syntax)
    println(<span class="hljs-string">"synthetic = "</span> + term.synthetic)
    println(<span class="hljs-string">"structure = "</span> + term.synthetic.structure)
}
<span class="hljs-comment">// term      = Future.apply[Int](3)</span>
<span class="hljs-comment">// synthetic = Some(*(global))</span>
<span class="hljs-comment">// structure = Some(ApplyTree(</span>
<span class="hljs-comment">//   OriginalTree(Term.Apply(</span>
<span class="hljs-comment">//     Term.ApplyType(</span>
<span class="hljs-comment">//       Term.Select(Term.Name("Future"), Term.Name("apply")),</span>
<span class="hljs-comment">//       List(Type.Name("Int"))</span>
<span class="hljs-comment">//     ),</span>
<span class="hljs-comment">//     List(Lit.Int(3))</span>
<span class="hljs-comment">//   )),</span>
<span class="hljs-comment">//   List(</span>
<span class="hljs-comment">//     IdTree(SymbolInformation(scala/concurrent/ExecutionContext.Implicits.global. =&gt; implicit lazy val method global: ExecutionContext))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// ))</span>
<span class="hljs-comment">// term      = Main.run</span>
<span class="hljs-comment">// synthetic = Some(*(message))</span>
<span class="hljs-comment">// structure = Some(ApplyTree(</span>
<span class="hljs-comment">//   OriginalTree(Term.Select(Term.Name("Main"), Term.Name("run"))),</span>
<span class="hljs-comment">//   List(</span>
<span class="hljs-comment">//     IdTree(SymbolInformation(_empty_/Main.message. =&gt; implicit val method message: String))</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// ))</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="look-up-inferred-type-parameters-for-infix-operators"></a><a href="#look-up-inferred-type-parameters-for-infix-operators" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Look up inferred type parameters for infix operators</h3>
<p>Infix operators such as <code>a ++ b</code> can have type parameters like <code>a ++[Int] b</code>.
Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">List</span>(<span class="hljs-number">1</span>) ++ <span class="hljs-type">List</span>(<span class="hljs-number">2</span>)
</code></pre>
<p>Use the <code>Term.ApplyInfix.syntheticOperator</code> to look up inferred type parameters
of infix operators.</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> concat @ <span class="hljs-type">Term</span>.<span class="hljs-type">ApplyInfix</span>(_, <span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"++"</span>), _, _) =&gt;
    println(<span class="hljs-string">".syntheticOperator = "</span> + concat.syntheticOperator)
    println(<span class="hljs-string">".structure         = "</span> + concat.syntheticOperator.structure)
}
<span class="hljs-comment">// .syntheticOperator = Some(*[Int,List[Int]])</span>
<span class="hljs-comment">// .structure         = Some(TypeApplyTree(</span>
<span class="hljs-comment">//   OriginalTree(Term.ApplyInfix(</span>
<span class="hljs-comment">//     Term.Apply(Term.Name("List"), List(Lit.Int(1))),</span>
<span class="hljs-comment">//     Term.Name("++"),</span>
<span class="hljs-comment">//     List(),</span>
<span class="hljs-comment">//     List(Term.Apply(Term.Name("List"), List(Lit.Int(2))))</span>
<span class="hljs-comment">//   )),</span>
<span class="hljs-comment">//   List(</span>
<span class="hljs-comment">//     TypeRef(NoType, Symbol("scala/Int#"), List()),</span>
<span class="hljs-comment">//     TypeRef(</span>
<span class="hljs-comment">//       NoType,</span>
<span class="hljs-comment">//       Symbol("scala/collection/immutable/List#"),</span>
<span class="hljs-comment">//       List(TypeRef(NoType, Symbol("scala/Int#"), List()))</span>
<span class="hljs-comment">//     )</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// ))</span>
</code></pre>
<p>The <code>.syntheticOperator</code> method is only available for <code>Term.ApplyInfix</code> nodes,
using the method on other node types results in a compilation error</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> concat @ <span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"++"</span>) =&gt;
    println(<span class="hljs-string">".syntheticOperator = "</span> + concat.syntheticOperator)
}
<span class="hljs-comment">// value syntheticOperator is not a member of scala.meta.Term.Name</span>
<span class="hljs-comment">//     println(".syntheticOperator = " + concat.syntheticOperator)</span>
<span class="hljs-comment">//                                              ^</span>
</code></pre>
<p>Beware that looking up synthetics for the infix operator name returns nothing</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> concat @ <span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"++"</span>) =&gt;
    println(<span class="hljs-string">".synthetic = "</span> + concat.synthetic)
}
<span class="hljs-comment">// .synthetic = None</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="look-up-for-comprehension-desugaring"></a><a href="#look-up-for-comprehension-desugaring" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Look up <code>for</code> comprehension desugaring</h3>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> numbers = <span class="hljs-keyword">for</span> {
  i &lt;- <span class="hljs-type">List</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
  j &lt;- <span class="hljs-number">1.</span>to(i)
} <span class="hljs-keyword">yield</span> i + j
<span class="hljs-keyword">for</span> (number &lt;- numbers) println(number)
</code></pre>
<p>Use <code>Tree.synthetic</code> on the tree node <code>Term.ForYield</code> to inspect the desugared
version of the <code>for { .. } yield</code> expression</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> forYield: <span class="hljs-type">Term</span>.<span class="hljs-type">ForYield</span> =&gt;
    println(<span class="hljs-string">".synthetic = "</span> + forYield.synthetic)
}
<span class="hljs-comment">// .synthetic = Some(orig(List(1, 2)).flatMap[Int,List[Int]](</span>
<span class="hljs-comment">//   { (i) =&gt;</span>
<span class="hljs-comment">//     orig(1.to(i)).map[Int,IndexedSeq[Int]]({ (j) =&gt; orig(i + j) })(</span>
<span class="hljs-comment">//       canBuildFrom[Int]</span>
<span class="hljs-comment">//     )</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// )(canBuildFrom[Int]))</span>
</code></pre>
<p>The <code>orig(List(1, 2))</code> and <code>orig(1.to(i)</code> parts represent <code>OriginalSubTree</code>
nodes that match non-synthetic tree nodes from the original for-comprension.</p>
<h2><a class="anchor" aria-hidden="true" id="known-limitations"></a><a href="#known-limitations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Known limitations</h2>
<p>The <code>SemanticTree</code> data structure does not encode all possible synthetic code
that may get generated at compile-time. See
<a href="https://github.com/scalameta/scalameta/issues/1711">scalameta/scalameta#1711</a>
if you are interested in contributing to improve the situation.</p>
<h3><a class="anchor" aria-hidden="true" id="for-patterns"></a><a href="#for-patterns" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>for</code> patterns</h3>
<p>For comprehensions that use patterns produce incomplete semantic trees.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">for</span> {
  (a, b) &lt;- <span class="hljs-type">List</span>(<span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span>) <span class="hljs-comment">// pattern</span>
} <span class="hljs-keyword">yield</span> a + b
</code></pre>
<p>Observe the empty <code>withFilter</code> body and <code>&lt;unknown&gt;</code> parameter symbol.</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> forYield: <span class="hljs-type">Term</span>.<span class="hljs-type">ForYield</span> =&gt;
    println(forYield.synthetic)
}
<span class="hljs-comment">// Some(</span>
<span class="hljs-comment">//   ApplyTree(</span>
<span class="hljs-comment">//     ApplyTree(</span>
<span class="hljs-comment">//       TypeApplyTree(</span>
<span class="hljs-comment">//         SelectTree(</span>
<span class="hljs-comment">//           ApplyTree(</span>
<span class="hljs-comment">//             SelectTree(</span>
<span class="hljs-comment">//               OriginalSubTree(</span>
<span class="hljs-comment">//                 Term.Apply(</span>
<span class="hljs-comment">//                   Term.Name("List"),</span>
<span class="hljs-comment">//                   List(</span>
<span class="hljs-comment">//                     Term.ApplyInfix(</span>
<span class="hljs-comment">//                       Lit.Int(1),</span>
<span class="hljs-comment">//                       Term.Name("-&gt;"),</span>
<span class="hljs-comment">//                       List(),</span>
<span class="hljs-comment">//                       List(Lit.Int(2))</span>
<span class="hljs-comment">//                     )</span>
<span class="hljs-comment">//                   )</span>
<span class="hljs-comment">//                 )</span>
<span class="hljs-comment">//               ),</span>
<span class="hljs-comment">//               IdTree(</span>
<span class="hljs-comment">//                 scala/collection/TraversableLike#withFilter(). =&gt; method withFilter(p: Function1[A, Boolean]): FilterMonadic[A, Repr]</span>
<span class="hljs-comment">//               )</span>
<span class="hljs-comment">//             ),</span>
<span class="hljs-comment">//             List(</span>
<span class="hljs-comment">//               FunctionTree(</span>
<span class="hljs-comment">//                 List(</span>
<span class="hljs-comment">//                   IdTree(</span>
<span class="hljs-comment">//                     local0 =&gt; param check$ifrefutable$1: Tuple2[Int, Int]</span>
<span class="hljs-comment">//                   )</span>
<span class="hljs-comment">//                 ),</span>
<span class="hljs-comment">//                 </span>
<span class="hljs-comment">//               )</span>
<span class="hljs-comment">//             )</span>
<span class="hljs-comment">//           ),</span>
<span class="hljs-comment">//           IdTree(</span>
<span class="hljs-comment">//             scala/collection/generic/FilterMonadic#map(). =&gt; abstract method map[B, That](f: Function1[A, B])(implicit bf: CanBuildFrom[Repr, B, That]): That</span>
<span class="hljs-comment">//           )</span>
<span class="hljs-comment">//         ),</span>
<span class="hljs-comment">//         List(</span>
<span class="hljs-comment">//           TypeRef(&lt;no type&gt;, scala/Int#, List()),</span>
<span class="hljs-comment">//           TypeRef(</span>
<span class="hljs-comment">//             &lt;no type&gt;,</span>
<span class="hljs-comment">//             scala/collection/immutable/List#,</span>
<span class="hljs-comment">// ...</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="for-assignments"></a><a href="#for-assignments" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>for</code> assignments</h3>
<p>For comprehensions that use assignments produce incomplete semantic trees.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">for</span> {
  a &lt;- <span class="hljs-type">List</span>(<span class="hljs-number">1</span>)
  b = a + <span class="hljs-number">1</span> <span class="hljs-comment">// assignment</span>
} <span class="hljs-keyword">yield</span> a + b
</code></pre>
<p>Observe the <code>&lt;unknown&gt;</code> parameter symbol to the final call to <code>map</code>.</p>
<pre><code class="hljs css language-scala">doc.tree.traverse {
  <span class="hljs-keyword">case</span> forYield: <span class="hljs-type">Term</span>.<span class="hljs-type">ForYield</span> =&gt;
    println(forYield.synthetic)
}
<span class="hljs-comment">// Some(</span>
<span class="hljs-comment">//   ApplyTree(</span>
<span class="hljs-comment">//     ApplyTree(</span>
<span class="hljs-comment">//       TypeApplyTree(</span>
<span class="hljs-comment">//         SelectTree(</span>
<span class="hljs-comment">//           ApplyTree(</span>
<span class="hljs-comment">//             ApplyTree(</span>
<span class="hljs-comment">//               TypeApplyTree(</span>
<span class="hljs-comment">//                 SelectTree(</span>
<span class="hljs-comment">//                   OriginalSubTree(</span>
<span class="hljs-comment">//                     Term.Apply(</span>
<span class="hljs-comment">//                       Term.Name("List"),</span>
<span class="hljs-comment">//                       List(Lit.Int(1))</span>
<span class="hljs-comment">//                     )</span>
<span class="hljs-comment">//                   ),</span>
<span class="hljs-comment">//                   IdTree(</span>
<span class="hljs-comment">//                     scala/collection/immutable/List#map(). =&gt; final method map[B, That](f: Function1[A, B])(implicit bf: CanBuildFrom[List[A], B, That]): That</span>
<span class="hljs-comment">//                   )</span>
<span class="hljs-comment">//                 ),</span>
<span class="hljs-comment">//                 List(</span>
<span class="hljs-comment">//                   TypeRef(</span>
<span class="hljs-comment">//                     &lt;no type&gt;,</span>
<span class="hljs-comment">//                     scala/Tuple2#,</span>
<span class="hljs-comment">//                     List(</span>
<span class="hljs-comment">//                       TypeRef(&lt;no type&gt;, scala/Int#, List()),</span>
<span class="hljs-comment">//                       TypeRef(&lt;no type&gt;, scala/Int#, List())</span>
<span class="hljs-comment">//                     )</span>
<span class="hljs-comment">//                   ),</span>
<span class="hljs-comment">//                   TypeRef(</span>
<span class="hljs-comment">//                     &lt;no type&gt;,</span>
<span class="hljs-comment">//                     scala/collection/immutable/List#,</span>
<span class="hljs-comment">//                     List(</span>
<span class="hljs-comment">//                       TypeRef(</span>
<span class="hljs-comment">//                         &lt;no type&gt;,</span>
<span class="hljs-comment">//                         scala/Tuple2#,</span>
<span class="hljs-comment">//                         List(</span>
<span class="hljs-comment">//                           TypeRef(</span>
<span class="hljs-comment">//                             &lt;no type&gt;,</span>
<span class="hljs-comment">//                             scala/Int#,</span>
<span class="hljs-comment">//                             List()</span>
<span class="hljs-comment">//                           ),</span>
<span class="hljs-comment">//                           TypeRef(</span>
<span class="hljs-comment">//                             &lt;no type&gt;,</span>
<span class="hljs-comment">//                             scala/Int#,</span>
<span class="hljs-comment">//                             List()</span>
<span class="hljs-comment">//                           )</span>
<span class="hljs-comment">// ...</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="macros"></a><a href="#macros" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Macros</h3>
<p>Macros can expand into arbitrary code including new definitions such as methods
and classes. Semantic trees only encode tree nodes that are generated by the
compiler through offical language features like type inference and implicit
search.</p>
<h2><a class="anchor" aria-hidden="true" id="semanticdb"></a><a href="#semanticdb" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SemanticDB</h2>
<p>The structure of <code>SemanticTree</code> mirrors SemanticDB <code>Tree</code>. Consult the
SemanticDB specification for more details about synthetics:</p>
<ul>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#type">General trees</a></li>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#java-tree">Scala trees</a></li>
</ul>
<p>The <code>SemanticTree</code> data structure diverges from SemanticDB <code>Tree</code> in few minor
details.</p>
<h3><a class="anchor" aria-hidden="true" id="semantictree-instead-of-tree"></a><a href="#semantictree-instead-of-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>SemanticTree</code> instead of <code>Tree</code></h3>
<p>Scalafix uses the name <code>SemanticTree</code> instead of <code>Tree</code> in order to avoid
ambiguous references with <code>scala.meta.Tree</code> when importing the two packages
together.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scalafix.v1._
<span class="hljs-keyword">import</span> scala.meta._
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="originaltree-vs-originalsubtree"></a><a href="#originaltree-vs-originalsubtree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>OriginalTree</code> vs. <code>OriginalSubTree</code></h3>
<p>Scalafix has two kinds of original trees, <code>OriginalTree</code> and <code>OriginalSubTree</code>,
while the SemanticDB specification has only one <code>OriginalTree</code>. The difference
between the two is that</p>
<ul>
<li><code>OriginalTree</code> represents synthetic trees whose range match exactly the
enclosing <code>Synthetic</code> range.</li>
<li><code>OriginalSubTree</code> represents trees whose range is smaller than the enclosing
<code>Synthetic</code> range.</li>
</ul>
<p>This change avoids the need for the SemanticDB <code>Synthetic</code> type.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/scalafix/docs/developers/semantic-type.html"><span class="arrow-prev">← </span><span>Previous</span></a><a class="docs-next button" href="/scalafix/docs/developers/contributing.html"><span>Next</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav docOnPageNav"><ul class="toc-headings"><li><a href="#cookbook">Cookbook</a><ul class="toc-headings"><li><a href="#look-up-inferred-type-parameter">Look up inferred type parameter</a></li><li><a href="#look-up-symbol-of-semantic-tree">Look up symbol of semantic tree</a></li><li><a href="#look-up-implicit-argument">Look up implicit argument</a></li><li><a href="#look-up-inferred-type-parameters-for-infix-operators">Look up inferred type parameters for infix operators</a></li><li><a href="#look-up-for-comprehension-desugaring">Look up <code>for</code> comprehension desugaring</a></li></ul></li><li><a href="#known-limitations">Known limitations</a><ul class="toc-headings"><li><a href="#for-patterns"><code>for</code> patterns</a></li><li><a href="#for-assignments"><code>for</code> assignments</a></li><li><a href="#macros">Macros</a></li></ul></li><li><a href="#semanticdb">SemanticDB</a><ul class="toc-headings"><li><a href="#semantictree-instead-of-tree"><code>SemanticTree</code> instead of <code>Tree</code></a></li><li><a href="#originaltree-vs-originalsubtree"><code>OriginalTree</code> vs. <code>OriginalSubTree</code></a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer" style="background-color:#15242B"><section class="sitemap"><a href="/scalafix/" class="nav-home"><img src="/scalafix/img/scalacenter2x.png" alt="Scalafix" width="66" height="58"/></a><div><h5>Docs</h5><a href="
                /scalafix/docs/users/installation.html">Get started</a><a href="
                /scalafix/docs/rules/overview.html">Rules</a><a href="
                /scalafix/docs/developers/setup.html">Extend Scalafix</a></div><div><h5>Community</h5><a href="https://gitter.im/scalacenter/scalafix" target="_blank">Chat on Gitter</a><a href="https://users.scala-lang.org/" target="_blank">Discuss on Scala Users</a></div><div><h5>More</h5><a href="https://github.com/scalacenter/scalafix" target="_blank">GitHub</a></div></section><section class="copyright">Copyright © 2018 Scala Center</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: 'cf575cebacff15579dd2dee010c4010f',
                indexName: 'scalafix',
                inputSelector: '#search_input_react'
              });
            </script></body></html>