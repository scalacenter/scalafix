<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>SymbolInformation · Scalafix</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Source:"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="SymbolInformation · Scalafix"/><meta property="og:type" content="website"/><meta property="og:url" content="https://scalacenter.github.io//scalafix/index.html"/><meta property="og:description" content="Source:"/><meta property="og:image" content="https://scalacenter.github.io//scalafix/img/scalacenter2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://scalacenter.github.io//scalafix/img/scalacenter2x.png"/><link rel="shortcut icon" href="/scalafix/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><script src="/scalafix/js/scrollSpy.js"></script><link rel="stylesheet" href="/scalafix/css/main.css"/><script src="/scalafix/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/scalafix/"><img class="logo" src="/scalafix/img/scalacenter2x.png" alt="Scalafix"/><h2 class="headerTitleWithLogo">Scalafix</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/scalafix/docs/users/installation.html" target="_self">User guide</a></li><li class="siteNavGroupActive"><a href="/scalafix/docs/developers/setup.html" target="_self">Developer guide</a></li><li class=""><a href="https://scalameta.org/metabrowse/#/scalafix/scalafix-core/src/main/scala/scalafix/patch/Patch.scala" target="_blank">Browse sources</a></li><li class=""><a href="https://github.com/scalacenter/scalafix" target="_blank">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>API Reference</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Implementing rules</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/setup.html">Setup</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/before-you-begin.html">Before you write code</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/tutorial.html">Tutorial</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/local-rules.html">Local rules</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/cross-publish-custom-rules.html">Cross publish custom rules</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API Reference</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/api.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/patch.html">Patch</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/symbol-matcher.html">SymbolMatcher</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/scalafix/docs/developers/symbol-information.html">SymbolInformation</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/semantic-type.html">SemanticType</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/semantic-tree.html">SemanticTree</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Contributing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/contributing.html">Guide</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/scalacenter/scalafix/edit/main/docs/developers/symbol-information.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">SymbolInformation</h1></header><article><div><span><p>Source:
<a href="https://scalameta.org/metabrowse/#/scalafix/scalafix-core/src/main/scala/scalafix/v1/SymbolInformation.scala" target="_blank">
<code>SymbolInformation.scala</code> </a></p>
<p><code>SymbolInformation</code> is a data structure containing metadata about a <code>Symbol</code>
definition. A symbol information describes the symbols's</p>
<ul>
<li>display name: the identifier used to reference this symbol</li>
<li>language: Scala, Java</li>
<li>kind: <code>class</code>, <code>trait</code>, <code>object</code>, ...</li>
<li>properties: <code>final</code>, <code>abstract</code>, <code>implicit</code></li>
<li>type signature: class declarations, class parents, method parameters, ...</li>
<li>visibility access: <code>private</code>, <code>protected</code>, ...</li>
<li>overridden symbols: list of symbols that this symbol overrides</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="cookbook"></a><a href="#cookbook" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cookbook</h2>
<p>All code examples in this document assume you have the following imports in
scope</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scalafix.v1._
<span class="hljs-keyword">import</span> scala.meta._
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="get-symbol-of-a-tree"></a><a href="#get-symbol-of-a-tree" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Get symbol of a tree</h3>
<p>Use <code>Tree.symbol</code> to get the symbol of a tree. Consider the following code.</p>
<pre><code class="hljs css language-scala">println(<span class="hljs-number">42</span>)
println()
</code></pre>
<p>To get the <code>println</code> symbol we match against the <code>Term.Name(&quot;println&quot;)</code> tree
node.</p>
<pre><code class="hljs css language-scala">doc.tree.collect {
  <span class="hljs-keyword">case</span> apply @ <span class="hljs-type">Term</span>.<span class="hljs-type">Apply</span>(println @ <span class="hljs-type">Term</span>.<span class="hljs-type">Name</span>(<span class="hljs-string">"println"</span>), _) =&gt;
    (apply.syntax, println.symbol)
}
<span class="hljs-comment">// res1: List[(String, Symbol)] = List(</span>
<span class="hljs-comment">//   ("println(42)", scala/Predef.println(+1).),</span>
<span class="hljs-comment">//   ("println()", scala/Predef.println().)</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="lookup-method-return-type"></a><a href="#lookup-method-return-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lookup method return type</h3>
<p>Use <code>MethodSignature.returnType</code> to inspect the return type of a method.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printReturnType</span></span>(symbol: <span class="hljs-type">Symbol</span>): <span class="hljs-type">Unit</span> = {
  symbol.info.get.signature <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> signature @ <span class="hljs-type">MethodSignature</span>(_, _, returnType) =&gt;
      println(<span class="hljs-string">"returnType = "</span> + returnType)
      println(<span class="hljs-string">"signature  = "</span> + signature)
      println(<span class="hljs-string">"structure  = "</span> + returnType.structure)
  }
}
printReturnType(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/Int#`+`()."</span>))
<span class="hljs-comment">// returnType = String</span>
<span class="hljs-comment">// signature  = (x: String): String</span>
<span class="hljs-comment">// structure  = TypeRef(NoType, Symbol("scala/Predef.String#"), List())</span>
printReturnType(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/Int#`+`(+4)."</span>))
<span class="hljs-comment">// returnType = Int</span>
<span class="hljs-comment">// signature  = (x: Int): Int</span>
<span class="hljs-comment">// structure  = TypeRef(NoType, Symbol("scala/Int#"), List())</span>
printReturnType(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/Option#map()."</span>))
<span class="hljs-comment">// returnType = Option[B]</span>
<span class="hljs-comment">// signature  = [B](f: Function1[A,B]): Option[B]</span>
<span class="hljs-comment">// structure  = TypeRef(</span>
<span class="hljs-comment">//   NoType,</span>
<span class="hljs-comment">//   Symbol("scala/Option#"),</span>
<span class="hljs-comment">//   List(TypeRef(NoType, Symbol("scala/Option#map().[B]"), List()))</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>The return type for constructor method signatures is always <code>NoType</code>.</p>
<pre><code class="hljs css language-scala">printReturnType(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/Some#`&lt;init&gt;`()."</span>))
<span class="hljs-comment">// returnType = &lt;no type&gt;</span>
<span class="hljs-comment">// signature  = (value: A): &lt;no type&gt;</span>
<span class="hljs-comment">// structure  = NoType</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="lookup-method-parameters"></a><a href="#lookup-method-parameters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lookup method parameters</h3>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Main.scala</span>
<span class="hljs-keyword">package</span> example
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span>(<span class="hljs-params">val constructorParam: <span class="hljs-type">Int</span></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">magic</span></span>: <span class="hljs-type">Int</span> = <span class="hljs-number">42</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">typeParam</span></span>[<span class="hljs-type">T</span>]: <span class="hljs-type">T</span> = ???
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">annotatedParam</span></span>(<span class="hljs-meta">@deprecatedName</span>(<span class="hljs-symbol">'a</span>) e: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = e
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">curried</span></span>(a: <span class="hljs-type">Int</span>)(b: <span class="hljs-type">Int</span>) = a + b
}
</code></pre>
<p>Use <code>MethodSignature.parameterLists</code> to look up parameters of a method.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printMethodParameters</span></span>(symbol: <span class="hljs-type">Symbol</span>): <span class="hljs-type">Unit</span> = {
  symbol.info.get.signature <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> signature @ <span class="hljs-type">MethodSignature</span>(typeParameters, parameterLists, _) =&gt;
      <span class="hljs-keyword">if</span> (typeParameters.nonEmpty) {
        println(<span class="hljs-string">"typeParameters"</span>)
        println(typeParameters.mkString(<span class="hljs-string">"  "</span>, <span class="hljs-string">"\n  "</span>, <span class="hljs-string">""</span>))
      }
      parameterLists.foreach { parameterList =&gt;
        println(<span class="hljs-string">"parametersList"</span>)
        println(parameterList.mkString(<span class="hljs-string">"  "</span>, <span class="hljs-string">"\n  "</span>, <span class="hljs-string">""</span>))
      }
  }
}
printMethodParameters(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#magic()."</span>))
printMethodParameters(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#typeParam()."</span>))
<span class="hljs-comment">// typeParameters</span>
<span class="hljs-comment">//   example/Main#typeParam().[T] =&gt; typeparam T</span>
printMethodParameters(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#annotatedParam()."</span>))
<span class="hljs-comment">// parametersList</span>
<span class="hljs-comment">//   example/Main#annotatedParam().(e) =&gt; @deprecatedName param e: Int</span>
printMethodParameters(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#`&lt;init&gt;`()."</span>))
<span class="hljs-comment">// parametersList</span>
<span class="hljs-comment">//   example/Main#`&lt;init&gt;`().(constructorParam) =&gt; val param constructorParam: Int</span>
</code></pre>
<p>Curried methods are distinguished by a <code>MethodSignature</code> with a parameter list
of length greater than 1.</p>
<pre><code class="hljs css language-scala">printMethodParameters(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#curried()."</span>))
<span class="hljs-comment">// parametersList</span>
<span class="hljs-comment">//   example/Main#curried().(a) =&gt; param a: Int</span>
<span class="hljs-comment">// parametersList</span>
<span class="hljs-comment">//   example/Main#curried().(b) =&gt; param b: Int</span>
printMethodParameters(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/Option#fold()."</span>))
<span class="hljs-comment">// typeParameters</span>
<span class="hljs-comment">//   scala/Option#fold().[B] =&gt; typeparam B</span>
<span class="hljs-comment">// parametersList</span>
<span class="hljs-comment">//   scala/Option#fold().(ifEmpty) =&gt; param ifEmpty: =&gt; B</span>
<span class="hljs-comment">// parametersList</span>
<span class="hljs-comment">//   scala/Option#fold().(f) =&gt; param f: Function1[A, B]</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="test-if-method-is-nullary"></a><a href="#test-if-method-is-nullary" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Test if method is nullary</h3>
<p>A &quot;nullary method&quot; is a method that is declared with no parameters and without
parentheses.</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Main.scala</span>
<span class="hljs-keyword">package</span> example
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Main</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nullary</span></span>: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nonNullary</span></span>(): <span class="hljs-type">Unit</span> = println(<span class="hljs-number">2</span>)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= <span class="hljs-string">"Main"</span>
}
</code></pre>
<p>Nullary method signatures are distinguished by having an no parameter lists:
<code>List()</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printParameterList</span></span>(symbol: <span class="hljs-type">Symbol</span>): <span class="hljs-type">Unit</span> = {
  symbol.info.get.signature <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">MethodSignature</span>(_, parameterLists, _) =&gt;
      println(parameterLists)
  }
}
printParameterList(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main.nullary()."</span>))
<span class="hljs-comment">// List()</span>
printParameterList(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/collection/Iterator#hasNext()."</span>))
<span class="hljs-comment">// List()</span>
</code></pre>
<p>Non-nullary methods such as <code>Iterator.next()</code> have a non-empty list of
parameters: <code>List(List())</code>.</p>
<pre><code class="hljs css language-scala">printParameterList(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main.nonNullary()."</span>))
<span class="hljs-comment">// List(List())</span>
printParameterList(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/collection/Iterator#next()."</span>))
<span class="hljs-comment">// List(List())</span>
</code></pre>
<p>Java does not have nullary methods so Java methods always have a non-empty list:
<code>List(List())</code>.</p>
<pre><code class="hljs css language-scala">printParameterList(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#isEmpty()."</span>))
<span class="hljs-comment">// List(List())</span>
printParameterList(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#toString()."</span>))
<span class="hljs-comment">// List(List())</span>
</code></pre>
<p>Scala methods that override Java methods always have non-nullary signatures even
if the Scala method is defined as nullary without parentheses.</p>
<pre><code class="hljs css language-scala">printParameterList(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main.toString()."</span>))
<span class="hljs-comment">// List(List())</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="lookup-type-alias"></a><a href="#lookup-type-alias" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lookup type alias</h3>
<p>Use <code>TypeSignature</code> to inspect type aliases.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printTypeAlias</span></span>(symbol: <span class="hljs-type">Symbol</span>): <span class="hljs-type">Unit</span> = {
  symbol.info.get.signature <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> signature @ <span class="hljs-type">TypeSignature</span>(typeParameters, lowerBound, upperBound) =&gt;
      <span class="hljs-keyword">if</span> (lowerBound == upperBound) {
        println(<span class="hljs-string">"Type alias where upperBound == lowerBound"</span>)
        println(<span class="hljs-string">"signature      = '"</span> + signature + <span class="hljs-string">"'"</span>)
        println(<span class="hljs-string">"typeParameters = "</span> + typeParameters.structure)
        println(<span class="hljs-string">"bound          = "</span> + upperBound.structure)
      } <span class="hljs-keyword">else</span> {
        println(<span class="hljs-string">"Different upper and lower bounds"</span>)
        println(<span class="hljs-string">"signature = '"</span> + signature + <span class="hljs-string">"'"</span>)
        println(<span class="hljs-string">"structure = "</span> + signature.structure)
      }
  }
}
</code></pre>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Main.scala</span>
<span class="hljs-keyword">package</span> example
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Main</span> </span>{
  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Number</span> </span>= <span class="hljs-type">Int</span>
  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Sequence</span>[<span class="hljs-type">T</span>] </span>= <span class="hljs-type">Seq</span>[<span class="hljs-type">T</span>]
  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Unbound</span></span>
  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">LowerBound</span> <span class="hljs-title">&gt;</span></span>: <span class="hljs-type">Int</span>
  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">UpperBound</span> <span class="hljs-title">&lt;</span></span>: <span class="hljs-type">String</span>
  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">UpperAndLowerBounded</span>  <span class="hljs-title">&gt;</span></span>: <span class="hljs-type">String</span> &lt;: <span class="hljs-type">CharSequence</span>
}
</code></pre>
<pre><code class="hljs css language-scala">printTypeAlias(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main.Number#"</span>))
<span class="hljs-comment">// Type alias where upperBound == lowerBound</span>
<span class="hljs-comment">// signature      = ' = Int'</span>
<span class="hljs-comment">// typeParameters = List()</span>
<span class="hljs-comment">// bound          = TypeRef(NoType, Symbol("scala/Int#"), List())</span>
printTypeAlias(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main.Sequence#"</span>))
<span class="hljs-comment">// Type alias where upperBound == lowerBound</span>
<span class="hljs-comment">// signature      = '[T] = Seq[T]'</span>
<span class="hljs-comment">// typeParameters = List(SymbolInformation(example/Main.Sequence#[T] =&gt; typeparam T))</span>
<span class="hljs-comment">// bound          = TypeRef(</span>
<span class="hljs-comment">//   NoType,</span>
<span class="hljs-comment">//   Symbol("scala/package.Seq#"),</span>
<span class="hljs-comment">//   List(TypeRef(NoType, Symbol("example/Main.Sequence#[T]"), List()))</span>
<span class="hljs-comment">// )</span>
printTypeAlias(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main.Unbound#"</span>))
<span class="hljs-comment">// Different upper and lower bounds</span>
<span class="hljs-comment">// signature = ''</span>
<span class="hljs-comment">// structure = TypeSignature(</span>
<span class="hljs-comment">//   List(),</span>
<span class="hljs-comment">//   TypeRef(NoType, Symbol("scala/Nothing#"), List()),</span>
<span class="hljs-comment">//   TypeRef(NoType, Symbol("scala/Any#"), List())</span>
<span class="hljs-comment">// )</span>
printTypeAlias(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main.LowerBound#"</span>))
<span class="hljs-comment">// Different upper and lower bounds</span>
<span class="hljs-comment">// signature = ' &gt;: Int'</span>
<span class="hljs-comment">// structure = TypeSignature(</span>
<span class="hljs-comment">//   List(),</span>
<span class="hljs-comment">//   TypeRef(NoType, Symbol("scala/Int#"), List()),</span>
<span class="hljs-comment">//   TypeRef(NoType, Symbol("scala/Any#"), List())</span>
<span class="hljs-comment">// )</span>
printTypeAlias(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main.UpperBound#"</span>))
<span class="hljs-comment">// Different upper and lower bounds</span>
<span class="hljs-comment">// signature = ' &lt;: String'</span>
<span class="hljs-comment">// structure = TypeSignature(</span>
<span class="hljs-comment">//   List(),</span>
<span class="hljs-comment">//   TypeRef(NoType, Symbol("scala/Nothing#"), List()),</span>
<span class="hljs-comment">//   TypeRef(NoType, Symbol("scala/Predef.String#"), List())</span>
<span class="hljs-comment">// )</span>
printTypeAlias(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main.UpperAndLowerBounded#"</span>))
<span class="hljs-comment">// Different upper and lower bounds</span>
<span class="hljs-comment">// signature = ' &gt;: String &lt;: CharSequence'</span>
<span class="hljs-comment">// structure = TypeSignature(</span>
<span class="hljs-comment">//   List(),</span>
<span class="hljs-comment">//   TypeRef(NoType, Symbol("scala/Predef.String#"), List()),</span>
<span class="hljs-comment">//   TypeRef(NoType, Symbol("java/lang/CharSequence#"), List())</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="lookup-class-parents"></a><a href="#lookup-class-parents" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lookup class parents</h3>
<p>Use <code>ClassSignature.parents</code> and <code>TypeRef.symbol</code> to lookup the class hierarchy.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getParentSymbols</span></span>(symbol: <span class="hljs-type">Symbol</span>): <span class="hljs-type">Set</span>[<span class="hljs-type">Symbol</span>] =
  symbol.info.get.signature <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">ClassSignature</span>(_, parents, _, _) =&gt;
      <span class="hljs-type">Set</span>(symbol) ++ parents.collect {
        <span class="hljs-keyword">case</span> <span class="hljs-type">TypeRef</span>(_, symbol, _) =&gt; getParentSymbols(symbol)
      }.flatten
  }
getParentSymbols(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#"</span>))
<span class="hljs-comment">// res28: Set[Symbol] = HashSet(</span>
<span class="hljs-comment">//   java/lang/String#,</span>
<span class="hljs-comment">//   java/io/Serializable#,</span>
<span class="hljs-comment">//   java/lang/CharSequence#,</span>
<span class="hljs-comment">//   java/lang/Comparable#,</span>
<span class="hljs-comment">//   java/lang/Object#</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="lookup-class-methods"></a><a href="#lookup-class-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lookup class methods</h3>
<p>Use <code>ClassSignature.declarations</code> and <code>SymbolInformation.isMethod</code> to query
methods of a class. Use <code>ClassSignature.parents</code> to query methods that are
inherited from supertypes.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getClassMethods</span></span>(symbol: <span class="hljs-type">Symbol</span>): <span class="hljs-type">Set</span>[<span class="hljs-type">SymbolInformation</span>] =
  symbol.info.get.signature <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">ClassSignature</span>(_, parents, _, declarations) =&gt;
      <span class="hljs-keyword">val</span> methods = declarations.filter(_.isMethod)
      methods.toSet ++ parents.collect {
        <span class="hljs-keyword">case</span> <span class="hljs-type">TypeRef</span>(_, symbol, _) =&gt; getClassMethods(symbol)
      }.flatten
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">Set</span>.empty
  }
getClassMethods(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/Some#"</span>)).take(<span class="hljs-number">5</span>)
<span class="hljs-comment">// res29: Set[SymbolInformation] = HashSet(</span>
<span class="hljs-comment">//   scala/Any#hashCode(). =&gt; abstract method hashCode(): Int,</span>
<span class="hljs-comment">//   scala/Option#isEmpty(). =&gt; final method isEmpty: Boolean,</span>
<span class="hljs-comment">//   scala/Equals#canEqual(). =&gt; abstract method canEqual(that: Any): Boolean,</span>
<span class="hljs-comment">//   scala/Any#isInstanceOf(). =&gt; final method isInstanceOf[A](): Boolean,</span>
<span class="hljs-comment">//   scala/Option#fold(). =&gt; @inline final method fold[B](ifEmpty: =&gt; B)(f: Function1[A, B]): B</span>
<span class="hljs-comment">// )</span>
getClassMethods(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#"</span>)).take(<span class="hljs-number">5</span>)
<span class="hljs-comment">// res30: Set[SymbolInformation] = HashSet(</span>
<span class="hljs-comment">//   java/lang/Object#toString(). =&gt; method toString(): String,</span>
<span class="hljs-comment">//   java/lang/CharSequence#subSequence(). =&gt; abstract method subSequence(param0: Int, param1: Int): CharSequence,</span>
<span class="hljs-comment">//   java/lang/Object#wait(+2). =&gt; final method wait(): Unit,</span>
<span class="hljs-comment">//   java/lang/Object#getClass(). =&gt; final method getClass(): Class[local_wildcard],</span>
<span class="hljs-comment">//   java/lang/String#toUpperCase(+1). =&gt; method toUpperCase(): String</span>
<span class="hljs-comment">// )</span>
getClassMethods(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/collection/immutable/List#"</span>)).take(<span class="hljs-number">5</span>)
<span class="hljs-comment">// res31: Set[SymbolInformation] = HashSet(</span>
<span class="hljs-comment">//   scala/collection/Iterable#className(). =&gt; protected[this] method className: String,</span>
<span class="hljs-comment">//   scala/collection/IterableOnce#knownSize(). =&gt; method knownSize: Int,</span>
<span class="hljs-comment">//   scala/collection/IterableOnceOps#tapEach(). =&gt; abstract method tapEach[U](f: Function1[A, U]): C,</span>
<span class="hljs-comment">//   scala/Any#`!=`(). =&gt; final method !=(that: Any): Boolean,</span>
<span class="hljs-comment">//   scala/collection/SeqOps#contains(). =&gt; method contains[A1 &gt;: A](elem: A1): Boolean</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>For Java methods, use <code>SymbolInformation.isStatic</code> to separate static methods
from non-static methods.</p>
<pre><code class="hljs css language-scala">getClassMethods(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#"</span>)).filter(_.isStatic).take(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res32: Set[SymbolInformation] = HashSet(</span>
<span class="hljs-comment">//   java/lang/String#indexOf(+5). =&gt; private[lang] static method indexOf(param0: Array[Char], param1: Int, param2: Int, param3: Array[Char], param4: Int, param5: Int, param6: Int): Int,</span>
<span class="hljs-comment">//   java/lang/String#valueOf(+3). =&gt; static method valueOf(param0: Boolean): String,</span>
<span class="hljs-comment">//   java/lang/String#copyValueOf(). =&gt; static method copyValueOf(param0: Array[Char], param1: Int, param2: Int): String</span>
<span class="hljs-comment">// )</span>
getClassMethods(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#"</span>)).filter(!_.isStatic).take(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res33: Set[SymbolInformation] = HashSet(</span>
<span class="hljs-comment">//   java/lang/String#getBytes(). =&gt; method getBytes(param0: Int, param1: Int, param2: Array[Byte], param3: Int): Unit,</span>
<span class="hljs-comment">//   java/lang/String#lastIndexOf(). =&gt; method lastIndexOf(param0: Int): Int,</span>
<span class="hljs-comment">//   java/lang/Object#wait(+2). =&gt; final method wait(): Unit</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="lookup-class-primary-constructor"></a><a href="#lookup-class-primary-constructor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lookup class primary constructor</h3>
<p>A primary constructor is the constructor that defined alongside the class
declaration.</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// User.scala</span>
<span class="hljs-keyword">package</span> example
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>) </span>{      <span class="hljs-comment">// primary constructor</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(name: <span class="hljs-type">String</span>) = <span class="hljs-keyword">this</span>(name, <span class="hljs-number">42</span>) <span class="hljs-comment">// secondary constructor</span>
}
</code></pre>
<p>Use <code>SymbolInformation.{isConstructor,isPrimary}</code> to distinguish a primary
constructor.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getConstructors</span></span>(symbol: <span class="hljs-type">Symbol</span>): <span class="hljs-type">List</span>[<span class="hljs-type">SymbolInformation</span>] =
  symbol.info.get.signature <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">ClassSignature</span>(_, parents, _, declarations) =&gt;
      declarations.filter { declaration =&gt;
        declaration.isConstructor
      }
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">Nil</span>
  }
getConstructors(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/User#"</span>)).filter(_.isPrimary)
<span class="hljs-comment">// res35: List[SymbolInformation] = List(</span>
<span class="hljs-comment">//   example/User#`&lt;init&gt;`(). =&gt; primary ctor &lt;init&gt;(name: String, age: Int)</span>
<span class="hljs-comment">// )</span>

<span class="hljs-comment">// secondary constructors are distinguished by not being primary</span>
getConstructors(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/User#"</span>)).filter(!_.isPrimary)
<span class="hljs-comment">// res36: List[SymbolInformation] = List(</span>
<span class="hljs-comment">//   example/User#`&lt;init&gt;`(+1). =&gt; ctor &lt;init&gt;(name: String)</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>Java constructors cannot be primary, &quot;primary constructor&quot; is a Scala-specific
feature.</p>
<pre><code class="hljs css language-scala">getConstructors(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#"</span>)).take(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res37: List[SymbolInformation] = List(</span>
<span class="hljs-comment">//   java/lang/String#`&lt;init&gt;`(). =&gt; ctor &lt;init&gt;(),</span>
<span class="hljs-comment">//   java/lang/String#`&lt;init&gt;`(+1). =&gt; ctor &lt;init&gt;(param0: String),</span>
<span class="hljs-comment">//   java/lang/String#`&lt;init&gt;`(+2). =&gt; ctor &lt;init&gt;(param0: Array[Char])</span>
<span class="hljs-comment">// )</span>
getConstructors(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#"</span>)).filter(_.isPrimary)
<span class="hljs-comment">// res38: List[SymbolInformation] = List()</span>
getConstructors(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/util/ArrayList#"</span>)).filter(_.isPrimary)
<span class="hljs-comment">// res39: List[SymbolInformation] = List()</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="lookup-case-class-fields"></a><a href="#lookup-case-class-fields" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lookup case class fields</h3>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// User.scala</span>
<span class="hljs-keyword">package</span> example
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>(secondaryName: <span class="hljs-type">String</span>) = <span class="hljs-keyword">this</span>(secondaryName, <span class="hljs-number">42</span>)
  <span class="hljs-keyword">val</span> upperCaseName = name.toUpperCase
}
</code></pre>
<p>On the symbol information level, there is no difference between <code>name</code> and
<code>upperCaseName</code>, both are <code>val method</code>.</p>
<pre><code class="hljs css language-scala">println(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/User#name."</span>).info)
<span class="hljs-comment">// Some(value = example/User#name. =&gt; val method name: String)</span>
println(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/User#upperCaseName."</span>).info)
<span class="hljs-comment">// Some(</span>
<span class="hljs-comment">//   value = example/User#upperCaseName. =&gt; val method upperCaseName: String</span>
<span class="hljs-comment">// )</span>
</code></pre>
<blockquote>
<p>See
<a href="https://github.com/scalameta/scalameta/issues/1492">scalameta/scalameta#1492</a>
for a discussion about adding <code>isSynthetic</code> to distinguish between <code>name</code> and
<code>upperCaseName</code>.</p>
</blockquote>
<p>Use the primary constructor to get the names of the case class fields</p>
<pre><code class="hljs css language-scala">getConstructors(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/User#"</span>)).foreach {
  <span class="hljs-keyword">case</span> ctor <span class="hljs-keyword">if</span> ctor.isPrimary =&gt;
    ctor.signature <span class="hljs-keyword">match</span> {
      <span class="hljs-keyword">case</span> <span class="hljs-type">MethodSignature</span>(_, parameters :: _, _) =&gt;
        <span class="hljs-keyword">val</span> names = parameters.map(_.displayName)
        println(<span class="hljs-string">"names: "</span> + names.mkString(<span class="hljs-string">", "</span>))
    }
  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-comment">// secondary constructor, ignore `this(secondaryName: String)`</span>
}
<span class="hljs-comment">// names: name, age</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="lookup-method-overloads"></a><a href="#lookup-method-overloads" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lookup method overloads</h3>
<p>Use <code>SymbolInformation.{isMethod,displayName}</code> to query for overloaded methods.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMethodOverloads</span></span>(classSymbol: <span class="hljs-type">Symbol</span>, methodName: <span class="hljs-type">String</span>): <span class="hljs-type">Set</span>[<span class="hljs-type">SymbolInformation</span>] =
  classSymbol.info.get.signature <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">ClassSignature</span>(_, parents, _, declarations) =&gt;
      <span class="hljs-keyword">val</span> overloadedMethods = declarations.filter { declaration =&gt;
        declaration.isMethod &amp;&amp;
        declaration.displayName == methodName
      }
      overloadedMethods.toSet ++ parents.collect {
        <span class="hljs-keyword">case</span> <span class="hljs-type">TypeRef</span>(_, symbol, _) =&gt; getMethodOverloads(symbol, methodName)
      }.flatten
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">Set</span>.empty
  }
getMethodOverloads(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#"</span>), <span class="hljs-string">"substring"</span>)
<span class="hljs-comment">// res44: Set[SymbolInformation] = Set(</span>
<span class="hljs-comment">//   java/lang/String#substring(). =&gt; method substring(param0: Int): String,</span>
<span class="hljs-comment">//   java/lang/String#substring(+1). =&gt; method substring(param0: Int, param1: Int): String</span>
<span class="hljs-comment">// )</span>
getMethodOverloads(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/Predef."</span>), <span class="hljs-string">"assert"</span>)
<span class="hljs-comment">// res45: Set[SymbolInformation] = Set(</span>
<span class="hljs-comment">//   scala/Predef.assert(). =&gt; @elidable method assert(assertion: Boolean): Unit,</span>
<span class="hljs-comment">//   scala/Predef.assert(+1). =&gt; @inline @elidable final method assert(assertion: Boolean, message: =&gt; Any): Unit</span>
<span class="hljs-comment">// )</span>
getMethodOverloads(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/Predef."</span>), <span class="hljs-string">"println"</span>)
<span class="hljs-comment">// res46: Set[SymbolInformation] = Set(</span>
<span class="hljs-comment">//   scala/Predef.println(). =&gt; method println(): Unit,</span>
<span class="hljs-comment">//   scala/Predef.println(+1). =&gt; method println(x: Any): Unit</span>
<span class="hljs-comment">// )</span>
getMethodOverloads(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/io/PrintStream#"</span>), <span class="hljs-string">"print"</span>).take(<span class="hljs-number">3</span>)
<span class="hljs-comment">// res47: Set[SymbolInformation] = HashSet(</span>
<span class="hljs-comment">//   java/io/PrintStream#print(+2). =&gt; method print(param0: Int): Unit,</span>
<span class="hljs-comment">//   java/io/PrintStream#print(). =&gt; method print(param0: Boolean): Unit,</span>
<span class="hljs-comment">//   java/io/PrintStream#print(+3). =&gt; method print(param0: Long): Unit</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>Overloaded methods can be inherited from supertypes.</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Main.scala</span>
<span class="hljs-keyword">package</span> example
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span></span>(width: <span class="hljs-type">Int</span>): <span class="hljs-type">String</span> = ???
}
</code></pre>
<pre><code class="hljs css language-scala">getMethodOverloads(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#"</span>), <span class="hljs-string">"toString"</span>)
<span class="hljs-comment">// res49: Set[SymbolInformation] = Set(</span>
<span class="hljs-comment">//   example/Main#toString(). =&gt; method toString(width: Int): String,</span>
<span class="hljs-comment">//   scala/Any#toString(). =&gt; abstract method toString(): String</span>
<span class="hljs-comment">// )</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="test-if-symbol-is-from-java-or-scala"></a><a href="#test-if-symbol-is-from-java-or-scala" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Test if symbol is from Java or Scala</h3>
<p>Use <code>SymbolInformation.{isScala,isJava}</code> to test if a symbol is defined in Java
or Scala.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printLanguage</span></span>(symbol: <span class="hljs-type">Symbol</span>): <span class="hljs-type">Unit</span> =
  <span class="hljs-keyword">if</span> (symbol.info.get.isJava) println(<span class="hljs-string">"java"</span>)
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (symbol.info.get.isScala) println(<span class="hljs-string">"scala"</span>)
  <span class="hljs-keyword">else</span> println(<span class="hljs-string">"unknown"</span>)

printLanguage(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#"</span>))
<span class="hljs-comment">// java</span>
printLanguage(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/Predef.String#"</span>))
<span class="hljs-comment">// scala</span>
</code></pre>
<p>Package symbols are neither defined in Scala or Java.</p>
<pre><code class="hljs css language-scala">printLanguage(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/"</span>))
<span class="hljs-comment">// unknown</span>
printLanguage(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/"</span>))
<span class="hljs-comment">// unknown</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="test-if-symbol-is-private"></a><a href="#test-if-symbol-is-private" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Test if symbol is private</h3>
<p>Access modifiers such as <code>private</code> and <code>protected</code> control the visibility of a
symbol.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printAccess</span></span>(symbol: <span class="hljs-type">Symbol</span>): <span class="hljs-type">Unit</span> = {
  <span class="hljs-keyword">val</span> info = symbol.info.get
  println(
         <span class="hljs-keyword">if</span> (info.isPrivate) <span class="hljs-string">"private"</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isPrivateThis) <span class="hljs-string">"private[this]"</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isPrivateWithin) <span class="hljs-string">s"private[<span class="hljs-subst">${info.within.get.displayName}</span>]"</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isProtected) <span class="hljs-string">"protected"</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isProtectedThis) <span class="hljs-string">"protected[this]"</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isProtectedWithin) <span class="hljs-string">s"protected[<span class="hljs-subst">${info.within.get.displayName}</span>]"</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isPublic) <span class="hljs-string">"public"</span>
    <span class="hljs-keyword">else</span> <span class="hljs-string">"&lt;no access&gt;"</span>
  )
}
</code></pre>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Main.scala</span>
<span class="hljs-keyword">package</span> example
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{
                     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">publicMethod</span>          </span>= <span class="hljs-number">1</span>
  <span class="hljs-keyword">private</span>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">privateMethod</span>         </span>= <span class="hljs-number">1</span>
  <span class="hljs-keyword">private</span>[<span class="hljs-keyword">this</span>]      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">privateThisMethod</span>     </span>= <span class="hljs-number">1</span>
  <span class="hljs-keyword">private</span>[example]   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">privateWithinMethod</span>   </span>= <span class="hljs-number">1</span>
  <span class="hljs-keyword">protected</span>          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">protectedMethod</span>       </span>= <span class="hljs-number">1</span>
  <span class="hljs-keyword">protected</span>[<span class="hljs-keyword">this</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">protectedThisMethod</span>   </span>= <span class="hljs-number">1</span>
  <span class="hljs-keyword">protected</span>[example] <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">protectedWithinMethod</span> </span>= <span class="hljs-number">1</span>
}
</code></pre>
<p>The methods have the following access modifiers.</p>
<pre><code class="hljs css language-scala">printAccess(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#publicMethod()."</span>))
<span class="hljs-comment">// public</span>
printAccess(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#privateMethod()."</span>))
<span class="hljs-comment">// private</span>
printAccess(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#privateThisMethod()."</span>))
<span class="hljs-comment">// private[this]</span>
printAccess(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#privateWithinMethod()."</span>))
<span class="hljs-comment">// private[example]</span>
printAccess(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#protectedMethod()."</span>))
<span class="hljs-comment">// protected</span>
printAccess(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#protectedThisMethod()."</span>))
<span class="hljs-comment">// protected[this]</span>
printAccess(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main#protectedWithinMethod()."</span>))
<span class="hljs-comment">// protected[example]</span>
</code></pre>
<p>Observe that a symbol can only have one kind of access modifier, for example
<code>isPrivate=false</code> for symbols where <code>isPrivateWithin=true</code>.</p>
<p>Java does supports smaller set of access modifiers, there is no <code>private[this]</code>,
<code>protected[this]</code> and <code>protected[within]</code> for Java symbols.</p>
<pre><code class="hljs css language-scala">printAccess(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#"</span>))
<span class="hljs-comment">// public</span>

println(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#value."</span>).info)
<span class="hljs-comment">// Some(</span>
<span class="hljs-comment">//   value = java/lang/String#value. =&gt; private final field value: Array[Char]</span>
<span class="hljs-comment">// )</span>
printAccess(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#value."</span>))
<span class="hljs-comment">// private</span>

println(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#`&lt;init&gt;`(+15)."</span>).info)
<span class="hljs-comment">// Some(</span>
<span class="hljs-comment">//   value = java/lang/String#`&lt;init&gt;`(+15). =&gt; private[lang] ctor &lt;init&gt;(param0: Array[Char], param1: Boolean)</span>
<span class="hljs-comment">// )</span>
printAccess(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/lang/String#`&lt;init&gt;`(+15)."</span>))
<span class="hljs-comment">// private[lang]</span>
</code></pre>
<p>Package symbols have no access restrictions.</p>
<pre><code class="hljs css language-scala">printAccess(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/"</span>))
<span class="hljs-comment">// &lt;no access&gt;</span>
printAccess(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"java/"</span>))
<span class="hljs-comment">// &lt;no access&gt;</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="lookup-symbol-annotations"></a><a href="#lookup-symbol-annotations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lookup symbol annotations</h3>
<p>Definitions such as classes, parameters and methods can be annotated with
<code>@annotation</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// Main.scala</span>
<span class="hljs-keyword">package</span> example
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Main</span> </span>{
  <span class="hljs-meta">@deprecated</span>(<span class="hljs-string">"Use add instead"</span>, <span class="hljs-string">"1.0"</span>)
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">+</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>) = add(a, b)

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">typed</span>[<span class="hljs-type">T</span>] <span class="hljs-keyword">extends</span> <span class="hljs-title">scala</span>.<span class="hljs-title">annotation</span>.<span class="hljs-title">StaticAnnotation</span></span>
  <span class="hljs-meta">@typed</span>[<span class="hljs-type">Int</span>]
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>) = a + b
}
</code></pre>
<p>Use <code>SymbolInformation.annotations</code> to query the annotations of a symbol.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printAnnotations</span></span>(symbol: <span class="hljs-type">Symbol</span>): <span class="hljs-type">Unit</span> =
  println(symbol.info.get.annotations.structure)

printAnnotations(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main.`+`()."</span>))
<span class="hljs-comment">// List(Annotation(TypeRef(NoType, Symbol("scala/deprecated#"), List())))</span>
printAnnotations(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"example/Main.add()."</span>))
<span class="hljs-comment">// List(</span>
<span class="hljs-comment">//   Annotation(TypeRef(</span>
<span class="hljs-comment">//     NoType,</span>
<span class="hljs-comment">//     Symbol("example/Main.typed#"),</span>
<span class="hljs-comment">//     List(TypeRef(NoType, Symbol("scala/Int#"), List()))</span>
<span class="hljs-comment">//   ))</span>
<span class="hljs-comment">// )</span>
printAnnotations(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/Predef.identity()."</span>))
<span class="hljs-comment">// List(Annotation(TypeRef(NoType, Symbol("scala/inline#"), List())))</span>
printAnnotations(<span class="hljs-type">Symbol</span>(<span class="hljs-string">"scala/Function2#[T1]"</span>))
<span class="hljs-comment">// List(Annotation(TypeRef(NoType, Symbol("scala/specialized#"), List())))</span>
</code></pre>
<p>It is not possible to query the term arguments of annotations. For example,
observe that the annotation for <code>Main.+</code> does not include the &quot;Use add instead&quot;
message.</p>
<h2><a class="anchor" aria-hidden="true" id="known-limitations"></a><a href="#known-limitations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Known limitations</h2>
<h3><a class="anchor" aria-hidden="true" id="lookup-method-overrides"></a><a href="#lookup-method-overrides" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lookup method overrides</h3>
<p>Consider the following program.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">A</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span>
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>{
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = a + b
}
</code></pre>
<p>There is no API to go from the symbol <code>B#add().</code> to the symbol it overrides
<code>A#add()</code>. There is also no <code>.isOverride</code> helper to test if a method overrides
another symbol.</p>
<h2><a class="anchor" aria-hidden="true" id="semanticdb"></a><a href="#semanticdb" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SemanticDB</h2>
<p>The structure of <code>SymbolInformation</code> in Scalafix mirrors SemanticDB
<code>SymbolInformation</code>. For comprehensive documentation about SemanticDB symbol
information consult the SemanticDB specification:</p>
<ul>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#symbolinformation">General symbol information</a></li>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#scala-symbolinformation">Scala symbol information</a></li>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#java-symbolinformation">Java symbol information</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="language"></a><a href="#language" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Language</h3>
<p>SemanticDB supports two languages: Scala and Java. Every symbol is either
defined in Scala or Java. To determine if a symbol is defined in Scala or in
Java, use the <code>isScala</code> and <code>isJava</code> methods. A symbol cannot be defined in both
Java and Scala.</p>
<h3><a class="anchor" aria-hidden="true" id="kind"></a><a href="#kind" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kind</h3>
<p>Every symbol has exactly one kind such as being a class or an interface. A
symbol can't have two kinds, for example it's not possible to be both a
constructor and a method. The available symbol kinds are:</p>
<ul>
<li><code>isLocal</code></li>
<li><code>isField</code></li>
<li><code>isMethod</code></li>
<li><code>isConstructor</code></li>
<li><code>isMacro</code></li>
<li><code>isType</code></li>
<li><code>isParameter</code></li>
<li><code>isSelfParameter</code></li>
<li><code>isTypeParameter</code></li>
<li><code>isObject</code></li>
<li><code>isPackage</code></li>
<li><code>isPackageObject</code></li>
<li><code>isClass</code></li>
<li><code>isInterface</code></li>
<li><code>isTrait</code></li>
</ul>
<p>Some kinds are limited to specific languages. For example, Scala symbols cannot
be fields and Java symbols cannot be traits.</p>
<h3><a class="anchor" aria-hidden="true" id="properties"></a><a href="#properties" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Properties</h3>
<p>A symbol can have zero or more properties such as <code>implicit</code> or <code>final</code>. The
available symbol properties are:</p>
<ul>
<li><code>isAbstract</code></li>
<li><code>isFinal</code></li>
<li><code>isSealed</code></li>
<li><code>isImplicit</code></li>
<li><code>isLazy</code></li>
<li><code>isCase</code></li>
<li><code>isCovariant</code></li>
<li><code>isContravariant</code></li>
<li><code>isVal</code></li>
<li><code>isVar</code></li>
<li><code>isStatic</code></li>
<li><code>isPrimary</code></li>
<li><code>isEnum</code></li>
<li><code>isDefault</code></li>
</ul>
<p>Consult the SemanticDB specification to learn which properties are valid for
each kind. For example, Scala traits can only be sealed, it is not valid for a
trait to be implicit or final.</p>
<h3><a class="anchor" aria-hidden="true" id="signature"></a><a href="#signature" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Signature</h3>
<p><code>Signature</code> is a sealed data structure that describes the shape of a symbol
definition.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Signature</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">with</span> <span class="hljs-title">Serializable</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span></span>: <span class="hljs-type">String</span> = <span class="hljs-type">Pretty</span>.pretty(<span class="hljs-keyword">this</span>).render(<span class="hljs-number">80</span>)
  <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span></span>(width: <span class="hljs-type">Int</span>): <span class="hljs-type">String</span> = <span class="hljs-type">Pretty</span>.pretty(<span class="hljs-keyword">this</span>).render(width)
  <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isEmpty</span></span>: <span class="hljs-type">Boolean</span> = <span class="hljs-keyword">this</span> == <span class="hljs-type">NoSignature</span>
  <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nonEmpty</span></span>: <span class="hljs-type">Boolean</span> = !isEmpty
}

<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueSignature</span>(<span class="hljs-params">tpe: <span class="hljs-type">SemanticType</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Signature</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassSignature</span>(<span class="hljs-params">
    typeParameters: <span class="hljs-type">List</span>[<span class="hljs-type">SymbolInformation</span>],
    parents: <span class="hljs-type">List</span>[<span class="hljs-type">SemanticType</span>],
    self: <span class="hljs-type">SemanticType</span>,
    declarations: <span class="hljs-type">List</span>[<span class="hljs-type">SymbolInformation</span>]
</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Signature</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodSignature</span>(<span class="hljs-params">
    typeParameters: <span class="hljs-type">List</span>[<span class="hljs-type">SymbolInformation</span>],
    parameterLists: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-type">SymbolInformation</span>]],
    returnType: <span class="hljs-type">SemanticType</span>
</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Signature</span></span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeSignature</span>(<span class="hljs-params">
    typeParameters: <span class="hljs-type">List</span>[<span class="hljs-type">SymbolInformation</span>],
    lowerBound: <span class="hljs-type">SemanticType</span>,
    upperBound: <span class="hljs-type">SemanticType</span>
</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Signature</span></span>
<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NoSignature</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Signature</span></span>
</code></pre>
<p>To learn more about SemanticDB signatures, consult the specification:</p>
<ul>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#signature">General signatures</a></li>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#scala-signature">Scala signatures</a></li>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#java-signature">Java signatures</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="annotation"></a><a href="#annotation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Annotation</h3>
<p>To learn more about SemanticDB annotations, consult the specification:</p>
<ul>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#annotation">General annotations</a></li>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#scala-annotation">Scala annotations</a></li>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#java-annotation">Java annotations</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="access"></a><a href="#access" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Access</h3>
<p>Some symbols are only accessible within restricted scopes, such as the enclosing
class or enclosing package. A symbol can only have one access, for example is
not valid for a symbol to be both private and private within. The available
access methods are:</p>
<ul>
<li><code>isPrivate</code></li>
<li><code>isPrivateThis</code></li>
<li><code>isPrivateWithin</code></li>
<li><code>isProtected</code></li>
<li><code>isProtectedThis</code></li>
<li><code>isProtectedWithin</code></li>
<li><code>isPublic</code></li>
</ul>
<p>To learn more about SemanticDB visibility access, consult the specification:</p>
<ul>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#access">General access</a></li>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#scala-access">Scala access</a></li>
<li><a href="https://scalameta.org/docs/semanticdb/specification.html#java-access">Java access</a></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="utility-methods"></a><a href="#utility-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Utility methods</h3>
<p>Some attributes of symbols are derived from a combination of language, kind and
property values. The following methods are available on <code>SymbolInformation</code> to
address common use-cases:</p>
<ul>
<li><code>isDef</code>: returns true if this symbol is a Scala <code>def</code>.</li>
<li><code>isSetter</code>: returns true if this is a setter symbol. For example, every global
<code>var</code> symbol has a corresponding setter symbol. Setter symbols are
distinguished by having a display name that ends with <code>_=</code>.</li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/scalafix/docs/developers/symbol-matcher.html"><span class="arrow-prev">← </span><span class="function-name-prevnext">SymbolMatcher</span></a><a class="docs-next button" href="/scalafix/docs/developers/semantic-type.html"><span class="function-name-prevnext">SemanticType</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#cookbook">Cookbook</a><ul class="toc-headings"><li><a href="#get-symbol-of-a-tree">Get symbol of a tree</a></li><li><a href="#lookup-method-return-type">Lookup method return type</a></li><li><a href="#lookup-method-parameters">Lookup method parameters</a></li><li><a href="#test-if-method-is-nullary">Test if method is nullary</a></li><li><a href="#lookup-type-alias">Lookup type alias</a></li><li><a href="#lookup-class-parents">Lookup class parents</a></li><li><a href="#lookup-class-methods">Lookup class methods</a></li><li><a href="#lookup-class-primary-constructor">Lookup class primary constructor</a></li><li><a href="#lookup-case-class-fields">Lookup case class fields</a></li><li><a href="#lookup-method-overloads">Lookup method overloads</a></li><li><a href="#test-if-symbol-is-from-java-or-scala">Test if symbol is from Java or Scala</a></li><li><a href="#test-if-symbol-is-private">Test if symbol is private</a></li><li><a href="#lookup-symbol-annotations">Lookup symbol annotations</a></li></ul></li><li><a href="#known-limitations">Known limitations</a><ul class="toc-headings"><li><a href="#lookup-method-overrides">Lookup method overrides</a></li></ul></li><li><a href="#semanticdb">SemanticDB</a><ul class="toc-headings"><li><a href="#language">Language</a></li><li><a href="#kind">Kind</a></li><li><a href="#properties">Properties</a></li><li><a href="#signature">Signature</a></li><li><a href="#annotation">Annotation</a></li><li><a href="#access">Access</a></li><li><a href="#utility-methods">Utility methods</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer" style="background-color:#15242B"><section class="sitemap"><a href="/scalafix/" class="nav-home"><img src="/scalafix/img/scalacenter2x.png" alt="Scalafix" width="66" height="58"/></a><div><h5>Docs</h5><a href="
                /scalafix/docs/users/installation.html">Get started</a><a href="
                /scalafix/docs/rules/overview.html">Rules</a><a href="
                /scalafix/docs/developers/setup.html">Extend Scalafix</a></div><div><h5>Community</h5><a href="https://gitter.im/scalacenter/scalafix" target="_blank">Chat on Gitter</a><a href="https://users.scala-lang.org/" target="_blank">Discuss on Scala Users</a></div><div><h5>More</h5><a href="https://github.com/scalacenter/scalafix" target="_blank">GitHub</a></div></section><section class="copyright">Copyright © 2021 Scala Center</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'cf575cebacff15579dd2dee010c4010f',
                indexName: 'scalafix',
                inputSelector: '#search_input_react'
              });
            </script></body></html>