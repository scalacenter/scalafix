<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Tutorial · Scalafix</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="In this tutorial, you will learn how to"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Tutorial · Scalafix"/><meta property="og:type" content="website"/><meta property="og:url" content="https://scalacenter.github.io//scalafix/index.html"/><meta property="og:description" content="In this tutorial, you will learn how to"/><meta property="og:image" content="https://scalacenter.github.io//scalafix/img/scalafix-brand-small2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://scalacenter.github.io//scalafix/img/scalafix-brand-small2x.png"/><link rel="shortcut icon" href="/scalafix/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><script src="/scalafix/js/scrollSpy.js"></script><link rel="stylesheet" href="/scalafix/css/main.css"/><script src="/scalafix/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/scalafix/"><img class="logo" src="/scalafix/img/scalafix-brand-small2x.png" alt="Scalafix"/><h2 class="headerTitleWithLogo">Scalafix</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/scalafix/docs/users/installation.html" target="_self">User guide</a></li><li class="siteNavGroupActive"><a href="/scalafix/docs/developers/setup.html" target="_self">Developer guide</a></li><li class=""><a href="https://scalameta.org/metabrowse/#/scalafix/scalafix-core/src/main/scala/scalafix/patch/Patch.scala" target="_blank">Browse sources</a></li><li class=""><a href="https://github.com/scalacenter/scalafix" target="_blank">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Implementing rules</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Implementing rules</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/setup.html">Setup</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/before-you-begin.html">Before you write code</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/scalafix/docs/developers/tutorial.html">Tutorial</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/local-rules.html">Local rules</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API Reference</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/api.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/patch.html">Patch</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/symbol-matcher.html">SymbolMatcher</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/symbol-information.html">SymbolInformation</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/semantic-type.html">SemanticType</a></li><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/semantic-tree.html">SemanticTree</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Contributing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scalafix/docs/developers/contributing.html">Guide</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/scalacenter/scalafix/edit/main/docs/developers/tutorial.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Tutorial</h1></header><article><div><span><p>In this tutorial, you will learn how to</p>
<ul>
<li>write unit tests for rewrite and linter rules</li>
<li>use pattern matching to find interesting tree nodes</li>
<li>use <code>SymbolInformation</code> to look up method signatures</li>
<li>use <code>Diagnostic</code> to report linter errors</li>
<li>use <code>withConfiguration</code> to make a rule configurable</li>
<li>use <code>atomic</code> to enable rule suppression</li>
<li>publish the rule so others can try it on their own codebase</li>
</ul>
<p>We are going to implement two different rules. The first rule is a semantic
rewrite <code>NamedLiteralArguments</code> that produces the following diff</p>
<pre><code class="hljs css language-diff">  def complete(isSuccess: Boolean): Unit = ???
<span class="hljs-deletion">- complete(true)</span>
<span class="hljs-addition">+ complete(isSuccess = true)</span>
</code></pre>
<p>The second rule is a syntactic linter <code>NoLiteralArguments</code> that reports an error
when a literal is used in argument position</p>
<pre><code class="hljs css language-scala">test/<span class="hljs-type">NamedLiteralArguments</span>.scala:<span class="hljs-number">9</span>:<span class="hljs-number">12</span>: error: [<span class="hljs-type">NoLiteralArguments</span>]:
<span class="hljs-type">Use</span> named arguments <span class="hljs-keyword">for</span> literals such as <span class="hljs-symbol">'parameterName</span> = <span class="hljs-literal">true</span>'
  complete(<span class="hljs-literal">true</span>)
           ^^^^
</code></pre>
<p>Let's get started!</p>
<h2><a class="anchor" aria-hidden="true" id="import-the-build"></a><a href="#import-the-build" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Import the build</h2>
<p>Start by cloning the repository
<a href="https://github.com/scalacenter/scalafix-named-literal-arguments">scalacenter/scalafix-named-literal-arguments</a>.</p>
<pre><code class="hljs">git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/scalacenter/scalafix-named-literal-arguments.git
<span class="hljs-keyword">cd</span> scalafix-named-literal-arguments/scalafix
sbt
...
[info] sbt server started at loca<span class="hljs-variable">l:</span>//$HOME/.sbt/<span class="hljs-number">1.0</span>/server/<span class="hljs-number">93</span>fc24de3bb97dec3e5b/sock
<span class="hljs-keyword">sb</span><span class="hljs-variable">t:scalafix</span>&gt;
</code></pre>
<p>This starts an sbt shell session from where you can run the test suite with
<code>tests / test</code>.</p>
<p>Optionally, if you use IntelliJ, import the build like normal with the action
&quot;New project from existing sources&quot; and select the <code>scalafix/build.sbt</code> file.</p>
<p>The sections in this tutorial follow the chronological order of the git history
so feel free to checkout older commits.</p>
<p>First we implement <code>NamedLiteralArguments</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="write-unit-tests"></a><a href="#write-unit-tests" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Write unit tests</h2>
<p>The build we just cloned is composed of four sub-projects</p>
<ul>
<li><code>rules</code>: where the <code>NamedLiteralArguments</code> rewrite rule is implemented</li>
<li><code>input</code>: where the code before the rewrite gets applied is written</li>
<li><code>output</code>: a mirror of the <code>input</code> project except with the expected code after
the rewrite has applied to the input files</li>
<li><code>tests</code>: where we run the unit tests</li>
</ul>
<p>For every file in the <code>input</code> project there should be a matching file in the
<code>output</code> project</p>
<pre><code class="hljs css language-sh">input/src
└── main
    └── scala
        └── fix
            └── NamedLiteralArguments.scala
output/src
└── main
    └── scala
        └── fix
            └── NamedLiteralArguments.scala
</code></pre>
<p>Checkout the first commit
<a href="https://github.com/scalacenter/scalafix-named-literal-arguments/commit/c03e5493b1e7ee9d82abebf2aa84b3bfcf01455b">c03e549</a>,
run <code>tests / test</code> and see the tests fail</p>
<pre><code class="hljs css language-diff"> &gt; ~tests / test
<span class="hljs-comment">--- obtained</span>
<span class="hljs-comment">+++ expected</span>
<span class="hljs-meta">@@ -4,3 +4,3 @@</span>
   def complete(isSuccess: Boolean): Unit = ()
<span class="hljs-deletion">-  complete(true)</span>
<span class="hljs-addition">+  complete(isSuccess = true)</span>
 }
</code></pre>
<p>The diff tells us that the expected fix (contents of <code>output</code> file) does not
match the output from running <code>NamedLiteralArguments</code> on the <code>input</code> file. We
expected the output to be <code>complete(isSuccess = true)</code> but the obtained output
was <code>complete(true)</code>. The <code>NamedLiteralArguments</code> rule currently returns
<code>Patch.empty</code> so the test failure is expected.</p>
<h2><a class="anchor" aria-hidden="true" id="use-pattern-matching-to-find-interesting-tree-nodes"></a><a href="#use-pattern-matching-to-find-interesting-tree-nodes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use pattern matching to find interesting tree nodes</h2>
<p>We update the rule implementation to traverse the syntax tree and find
occurrences of the literal <code>true</code>.</p>
<pre><code class="hljs css language-scala">doc.tree.collect {
  <span class="hljs-keyword">case</span> t @ <span class="hljs-string">q"true"</span> =&gt; <span class="hljs-type">Patch</span>.addLeft(t, <span class="hljs-string">"isSuccess = "</span>)
}.asPatch
</code></pre>
<p>Let's break this down:</p>
<ul>
<li><code>doc.tree.collect { case =&gt; ...}</code>: perform a top-to-bottom traversal of the
syntax tree</li>
<li>we construct a Scalameta
<a href="https://scalameta.org/docs/trees/quasiquotes.html">&quot;quasiquote&quot;</a> pattern
<code>q&quot;true&quot;</code> which matches any tree node that represents the boolean literal
<code>true</code>.</li>
<li><code>Patch.addLeft(t, &quot;isSuccess = &quot;)</code>: describes a refactoring on the source code
that adds the string <code>isSuccess =</code> to the left side of the <code>true</code> literal.</li>
<li><code>List[Patch].asPatch</code>: helper method to convert a list of patches into a
single patch.</li>
</ul>
<p>This solution is simple but it is incomplete</p>
<ul>
<li>the rewrite triggers only for the literal <code>true</code> but not <code>false</code></li>
<li>the rewrite triggers for any <code>true</code> literal even if it is not a function
argument. For example, <code>val done = true</code> becomes
<code>val done = isSuccess = true</code>.</li>
<li>the rewrite triggers even if rule suppression is active, i.e. <code>// scalafix:ok</code> is present.</li>
</ul>
<p>The first improvement we make is to handle both <code>true</code> and <code>false</code> literals.</p>
<pre><code class="hljs css language-diff"><span class="hljs-deletion">-  case t @ q"true" =&gt;</span>
<span class="hljs-addition">+  case t @ Lit.Boolean(_) =&gt;</span>
</code></pre>
<p>We replace the <code>q&quot;true&quot;</code> quasiquote with <code>Lit.Boolean(_)</code>. Quasiquotes are great
for constructing static tree nodes but pattern matching against named tree nodes
like <code>Lit.Boolean(_)</code> can be more flexible when you need fine-grained control.</p>
<p>To find the name of a tree node you can use
<a href="http://astexplorer.net/#/gist/ec56167ffafb20cbd8d68f24a37043a9/74efb238ad02abaa8fa69fc80342563efa8a1bdc">AST Explorer</a>
or <code>tree.structure</code>. First, make sure you have the following imports</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scalafix.v1._
<span class="hljs-keyword">import</span> scala.meta._
</code></pre>
<p>Next, use the <code>.structure</code> and <code>.structure(width: Int)</code> extension methods on
trees.</p>
<pre><code class="hljs css language-scala">println(<span class="hljs-string">q"complete(true)"</span>.structure)     <span class="hljs-comment">// line wrap at 80th column</span>
<span class="hljs-comment">// Term.Apply(Term.Name("complete"), Term.ArgClause(List(Lit.Boolean(true)), None))</span>
println(<span class="hljs-string">q"complete(true)"</span>.structureWidth(<span class="hljs-number">30</span>)) <span class="hljs-comment">// line wrap at 30th column</span>
<span class="hljs-comment">// Term.Apply(</span>
<span class="hljs-comment">//   Term.Name("complete"),</span>
<span class="hljs-comment">//   Term.ArgClause(</span>
<span class="hljs-comment">//     List(Lit.Boolean(true)),</span>
<span class="hljs-comment">//     None</span>
<span class="hljs-comment">//   )</span>
<span class="hljs-comment">// )</span>
</code></pre>
<p>The output of <code>tree.structure</code> can be copy-pasted for use in pattern matching.</p>
<p>The next improvement is to ensure we only rewrite boolean literals that appear
in function argument position. Previously, the rewrite would replace appearances
of <code>true</code> anywhere, producing problematic diffs like this</p>
<pre><code class="hljs css language-diff"><span class="hljs-deletion">- val isComplete = true</span>
<span class="hljs-addition">+ val isComplete = isSuccess = true</span>
</code></pre>
<p>To fix this bug, we first match function call nodes <code>Term.Apply</code> and pattern
match only <code>Lit.Boolean</code> that appear in argument position</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-type">Term</span>.<span class="hljs-type">Apply</span>(_, args) =&gt;
  args.collect {
    <span class="hljs-keyword">case</span> t @ <span class="hljs-type">Lit</span>.<span class="hljs-type">Boolean</span>(_) =&gt;
      <span class="hljs-type">Patch</span>.addLeft(t, <span class="hljs-string">"isSuccess = "</span>)
  }
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="use-symbolinformation-to-lookup-method-signatures"></a><a href="#use-symbolinformation-to-lookup-method-signatures" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use <code>SymbolInformation</code> to lookup method signatures</h2>
<p>Our rule is still unfinished because we have hard-coded <code>isSuccess</code>. Let's add a
test case to reproduce this bug</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complete</span></span>(isSuccess: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Unit</span> = ()
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">finish</span></span>(isError: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Unit</span> = ()
complete(<span class="hljs-literal">true</span>)
finish(<span class="hljs-literal">true</span>)
</code></pre>
<p>The rule currently produces <code>finish(isSuccess = true)</code> but the correct solution
is to produce <code>finish(isError = true)</code>.</p>
<p>To fix this bug, we start by capturing the called method into a variable <code>fun</code></p>
<pre><code class="hljs css language-diff"><span class="hljs-deletion">- case Term.Apply(_, args) =&gt;</span>
<span class="hljs-addition">+ case Term.Apply(fun, args) =&gt;</span>
</code></pre>
<p>We update the call to <code>args.collect</code> to include the index of the argument</p>
<pre><code class="hljs css language-diff"><span class="hljs-deletion">- args.collect { case Lit.Boolean(_) =&gt; ...</span>
<span class="hljs-addition">+ args.zipWithIndex.collect { case (Lit.Boolean(_), i) =&gt; ...</span>
</code></pre>
<p>Next, we use the method <code>Tree.symbol.info</code> to query information about the method
we are calling</p>
<pre><code class="hljs css language-diff">  case Lit.Boolean(_) =&gt;
<span class="hljs-addition">+   fun.symbol.info match {</span>
<span class="hljs-addition">+     case Some(info) =&gt;</span>
        // ...
<span class="hljs-addition">+     case None =&gt;</span>
<span class="hljs-addition">+       // Do nothing, no information about this symbol.</span>
<span class="hljs-addition">+       Patch.empty</span>
<span class="hljs-addition">+   }</span>
</code></pre>
<ul>
<li><code>Tree.symbol</code> returns a <code>Symbol</code>, which represents the unique identifier of
definition such as a <code>val</code> or a <code>class</code>.</li>
<li><code>Symbol.info</code> returns a
<a href="https://static.javadoc.io/ch.epfl.scala/scalafix-core_2.12/0.14.3/scalafix/v1/SymbolInformation.html"><code>SymbolInformation</code></a>,
which contains metadata about that symbol.</li>
</ul>
<p>Next, we use <code>SymbolInformation.signature</code> to see if the symbol is a method with
a non-empty parameter list.</p>
<pre><code class="hljs css language-diff"><span class="hljs-addition">+ info.signature match {</span>
<span class="hljs-addition">+   case method: MethodSignature if method.parameterLists.nonEmpty =&gt;</span>
      // ...
<span class="hljs-addition">+   case _ =&gt;</span>
<span class="hljs-addition">+     // Do nothing, the symbol is not a method with matching signature</span>
<span class="hljs-addition">+     Patch.empty</span>
<span class="hljs-addition">+ }</span>
</code></pre>
<p>The next step is to extract the parameter at the index of the argument</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> parameter = method.parameterLists.head(i)
<span class="hljs-keyword">val</span> parameterName = parameter.displayName
<span class="hljs-type">Patch</span>.addLeft(t, <span class="hljs-string">s"<span class="hljs-subst">$parameterName</span> = "</span>)
</code></pre>
<p>We're not done quite yet, because the rule does not respect rule suppression comments like <code>// scalafix:ok</code>.  Let's add a test case to reproduce this bug</p>
<pre><code class="hljs css language-scala">complete(<span class="hljs-literal">false</span>) <span class="hljs-comment">// scalafix:ok; rule suppression</span>
</code></pre>
<p>We can fix this bug by specifying that <code>Patch.addLeft</code> should be <code>atomic</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Patch</span>.addLeft(t, <span class="hljs-string">s"<span class="hljs-subst">$parameterName</span> = "</span>).atomic
</code></pre>
<p>That completes the <code>NamedLiteralArguments</code> rule! Run all tests and we see they
pass. Putting it together, the final code for the rule looks like this</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// NamedLiteralArguments.scala</span>
<span class="hljs-keyword">package</span> fix

<span class="hljs-keyword">import</span> scalafix.v1._
<span class="hljs-keyword">import</span> scala.meta._

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NamedLiteralArguments</span></span>
    <span class="hljs-keyword">extends</span> <span class="hljs-type">SemanticRule</span>(<span class="hljs-string">"NamedLiteralArguments"</span>) {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fix</span></span>(<span class="hljs-keyword">implicit</span> doc: <span class="hljs-type">SemanticDocument</span>): <span class="hljs-type">Patch</span> = {
    doc.tree.collect {
      <span class="hljs-keyword">case</span> <span class="hljs-type">Term</span>.<span class="hljs-type">Apply</span>(fun, args) =&gt;
        args.zipWithIndex.collect {
          <span class="hljs-keyword">case</span> (t @ <span class="hljs-type">Lit</span>.<span class="hljs-type">Boolean</span>(_), i) =&gt;
            fun.symbol.info <span class="hljs-keyword">match</span> {
              <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(info) =&gt;
                info.signature <span class="hljs-keyword">match</span> {
                  <span class="hljs-keyword">case</span> method: <span class="hljs-type">MethodSignature</span>
                      <span class="hljs-keyword">if</span> method.parameterLists.nonEmpty =&gt;
                    <span class="hljs-keyword">val</span> parameter = method.parameterLists.head(i)
                    <span class="hljs-keyword">val</span> parameterName = parameter.displayName
                    <span class="hljs-type">Patch</span>.addLeft(t, <span class="hljs-string">s"<span class="hljs-subst">$parameterName</span> = "</span>).atomic
                  <span class="hljs-keyword">case</span> _ =&gt;
                    <span class="hljs-comment">// Do nothing, the symbol is not a method with matching signature</span>
                    <span class="hljs-type">Patch</span>.empty
                }
              <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt;
                <span class="hljs-comment">// Do nothing, no information about this symbol.</span>
                <span class="hljs-type">Patch</span>.empty
            }
        }
    }.flatten.asPatch
  }
}
</code></pre>
<p>Next, we learn how to implement a syntactic linter.</p>
<h2><a class="anchor" aria-hidden="true" id="use-diagnostic-to-report-linter-errors"></a><a href="#use-diagnostic-to-report-linter-errors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use <code>Diagnostic</code> to report linter errors</h2>
<p>Let's say we want to report an error message when an argument is a literal
instead of automatically inserting the parameter name. The user would see a
diagnostic like this</p>
<pre><code class="hljs css language-scala">test/<span class="hljs-type">NamedLiteralArguments</span>.scala:<span class="hljs-number">9</span>:<span class="hljs-number">12</span>: error: [<span class="hljs-type">NoLiteralArguments</span>]:
<span class="hljs-type">Use</span> named arguments <span class="hljs-keyword">for</span> literals such as <span class="hljs-symbol">'parameterName</span> = <span class="hljs-literal">true</span>'
  complete(<span class="hljs-literal">true</span>)
           ^^^^
</code></pre>
<p>The benefit of making <code>NamedLiteralArguments</code> a syntactic linter instead of a
semantic rewrite is that it's simpler to run syntactic rules since they don't
require compilation. However, the downside is that we can't look up the correct
parameter name. The linter can be syntactic because it doesn't need to use
<code>SymbolInformation</code> to look up the parameter name.</p>
<p>First, let's create a diagnostic that produces the error message</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiteralArgument</span>(<span class="hljs-params">literal: <span class="hljs-type">Lit</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Diagnostic</span> </span>{
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">position</span></span>: <span class="hljs-type">Position</span> = literal.pos
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">message</span></span>: <span class="hljs-type">String</span> =
    <span class="hljs-string">s"Use named arguments for literals such as 'parameterName = <span class="hljs-subst">$literal</span>'"</span>
}
</code></pre>
<p>Next, we create a new syntactic rule <code>NoLiteralArguments</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoLiteralArguments</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SyntacticRule</span>(<span class="hljs-params">"<span class="hljs-type">NoLiteralArguments</span>"</span>) </span>{
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fix</span></span>(<span class="hljs-keyword">implicit</span> doc: <span class="hljs-type">SyntacticDocument</span>): <span class="hljs-type">Patch</span> = {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
<p>Next, update <code>META-INF/services/scalafix.v1.Rule</code> to include the new rule so
that Scalafix can load the rule by it's name <code>rules = [ NoLiteralArguments ]</code>.
Consult the JDK
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html">ServiceLoader</a>
documentation to learn more about how Scalafix loads rules.</p>
<pre><code class="hljs css language-diff">  fix.NamedLiteralArguments
<span class="hljs-addition">+ fix.NoLiteralArguments</span>
</code></pre>
<p>Note that the <em>name</em> of the rule is the string passed as an argument to
<code>SyntacticRule</code>. While usually it is named after the class, they can be
different. Keep in mind it's the fully-qualified class name listed in
<code>scalafix.v1.Rule</code>, and it's the rule name that Scalafix can then use.</p>
<p>We create a new input file to test <code>NoLiteralArguments</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">/*
rule = NoLiteralArguments
 */</span>
<span class="hljs-keyword">package</span> test

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoLiteralArguments</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complete</span></span>(isSuccess: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Unit</span> = ()
  complete(<span class="hljs-literal">true</span>) <span class="hljs-comment">// assert: NoLiteralArguments</span>
  complete(<span class="hljs-literal">true</span>) <span class="hljs-comment">// scalafix:ok; should not assert</span>
}
</code></pre>
<p>The comment <code>// assert: NoLiteralArguments</code> asserts that a diagnostic is
reported at the line of <code>complete(true)</code>. There is no need to write an output
file since linters don't modify the input source code.</p>
<p>Next, we write the same pattern matching logic as in <code>NamedLiteralArguments</code></p>
<pre><code class="hljs css language-scala">doc.tree.collect {
  <span class="hljs-keyword">case</span> <span class="hljs-type">Term</span>.<span class="hljs-type">Apply</span>(_, args) =&gt;
    args.collect {
      <span class="hljs-keyword">case</span> t @ <span class="hljs-type">Lit</span>.<span class="hljs-type">Boolean</span>(_) =&gt;
        <span class="hljs-comment">// ....</span>
    }
}.flatten.asPatch
</code></pre>
<p>Finally, to report a diagnostic we use <code>Patch.lint</code> (which supports rule suppression comments out of the box)</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Patch</span>.lint(<span class="hljs-type">LiteralArgument</span>(t))
</code></pre>
<p>We run the tests and see that they pass. Let's add a <code>/*</code> multi-line assertion
to make sure the position and message of the diagnostic make sense</p>
<pre><code class="hljs css language-diff">  complete(true) // assert: NoLiteralArguments
  complete(true) // scalafix:ok; should not assert
<span class="hljs-addition">+ complete(false) /* assert: NoLiteralArguments</span>
<span class="hljs-addition">+          ^^^^^</span>
<span class="hljs-addition">+ Use named arguments for literals such as 'parameterName = false'</span>
<span class="hljs-addition">+ */</span>
</code></pre>
<blockquote>
<p>It's a good practice to write at least one <code>/*</code> multi-line assertion for the
position and message contents of a diagnostic.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="use-withconfiguration-to-make-a-rule-configurable"></a><a href="#use-withconfiguration-to-make-a-rule-configurable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use <code>withConfiguration</code> to make a rule configurable</h2>
<p>The <code>NoLiteralArguments</code> linter reports errors for <strong>boolean</strong> literals but in
some cases we might want an error for other types of literals such as magic
<strong>numbers</strong> and <strong>strings</strong>. Since users may have different preferences, let's
allow them to decide which literal types to prohibit through configuration in
<code>.scalafix.conf</code></p>
<pre><code class="hljs css language-conf"><span class="hljs-string">//</span> <span class="hljs-string">.scalafix.conf</span>
NoLiteralArguments.disabledLiterals = [
  <span class="hljs-string">"Int"</span>,
  <span class="hljs-string">"String"</span>,
  <span class="hljs-string">"Boolean"</span>
]
</code></pre>
<p>Let's start by adding a failing test suite by adding a new input file
<code>NoLiteralArgumentsConfig.scala</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">/*
rule = NoLiteralArguments
NoLiteralArguments.disabledLiterals = [
  Int
  Boolean
]
 */</span>
<span class="hljs-keyword">package</span> test

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoLiteralArgumentsConfig</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complete</span></span>(message: <span class="hljs-type">String</span>): <span class="hljs-type">Unit</span> = ()
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complete</span></span>(count: <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = ()
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complete</span></span>(isSuccess: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Unit</span> = ()
  complete(<span class="hljs-string">"done"</span>) <span class="hljs-comment">// ok, no error message</span>
  complete(<span class="hljs-number">42</span>) <span class="hljs-comment">// assert: NoLiteralArguments</span>
  complete(<span class="hljs-literal">true</span>) <span class="hljs-comment">// assert: NoLiteralArguments</span>
  complete(<span class="hljs-literal">true</span>) <span class="hljs-comment">// scalafix:ok; rule suppression</span>
}
</code></pre>
<p>The top of the file contains <code>.scalafix.conf</code> configuration that is passed to
rules when they're loaded.</p>
<p>If we run <code>tests / test</code> we get an error like this</p>
<pre><code class="hljs css language-scala">===========&gt; <span class="hljs-type">Unreported</span> &lt;===========
fix/<span class="hljs-type">NoLiteralArgumentsConfig</span>.scala:<span class="hljs-number">16</span>:<span class="hljs-number">16</span>: error
  complete(<span class="hljs-number">42</span>) <span class="hljs-comment">// assert: NoLiteralArguments</span>
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-------
</code></pre>
<p>An &quot;unreported&quot; error message means we asserted a diagnostic would be reported
at this line but no diagnostic was reported. This is expected since we don't
read the configuration yet.</p>
<p>Start by writing a case class to hold the configuration</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoLiteralArgumentsConfig</span>(<span class="hljs-params">
    disabledLiterals: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>("<span class="hljs-type">Boolean</span>"</span>)</span>
) {
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isDisabled</span></span>(lit: <span class="hljs-type">Lit</span>): <span class="hljs-type">Boolean</span> = {
    <span class="hljs-keyword">val</span> kind = lit.productPrefix.stripPrefix(<span class="hljs-string">"Lit."</span>)
    disabledLiterals.contains(kind)
  }
}
</code></pre>
<p>Next we update the rule to have an instance of the configuration</p>
<pre><code class="hljs css language-diff"><span class="hljs-deletion">- class NoLiteralArguments extends SyntacticRule("NoLiteralArguments")</span>
<span class="hljs-addition">+ class NoLiteralArguments(config: NoLiteralArgumentsConfig)</span>
<span class="hljs-addition">+     extends SyntacticRule("NoLiteralArguments")</span>
<span class="hljs-addition">+   def this() = this(NoLiteralArgumentsConfig())</span>
</code></pre>
<blockquote>
<p>It's important to keep an empty constructor <code>def this() = ...</code> so that
Scalafix can load the rule. If we forget the empty constructor we get an error
like this: &quot;java.lang.NoSuchMethodException: Provider fix.NoLiteralArguments
could not be instantiated&quot;</p>
</blockquote>
<p>Next, we create a companion object with decoders to read <code>.scalafix.conf</code>
configuration into <code>NoLiteralArgumentsConfig</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NoLiteralArgumentsConfig</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">default</span> </span>= <span class="hljs-type">NoLiteralArgumentsConfig</span>()
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> surface =
    metaconfig.generic.deriveSurface[<span class="hljs-type">NoLiteralArgumentsConfig</span>]
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> decoder =
    metaconfig.generic.deriveDecoder(<span class="hljs-keyword">default</span>)
}
</code></pre>
<p>To learn more about decoding configuration, consult the
<a href="https://olafurpg.github.io/metaconfig/">metaconfig docs</a>.</p>
<p>Next, we override the <code>withConfiguration</code> method to read user configuration.</p>
<pre><code class="hljs css language-diff">  class NoLiteralArguments(config: NoLiteralArgumentsConfig)
      extends SyntacticRule("NoLiteralArguments") {
<span class="hljs-addition">+   override def withConfiguration(config: Configuration): Configured[Rule] =</span>
<span class="hljs-addition">+     config.conf</span>
<span class="hljs-addition">+       .getOrElse("NoLiteralArguments")(this.config)</span>
<span class="hljs-addition">+       .map { newConfig =&gt; new NoLiteralArguments(newConfig) }</span>
</code></pre>
<p>The <code>withConfiguration</code> method is called once after the rule is loaded. The same
rule instance is then used to process multiple files in the same project.</p>
<p>The final step is to use the configuration to report errors only for literals
types the user has configured to prohibit</p>
<pre><code class="hljs css language-diff"><span class="hljs-deletion">- case t: Lit.Boolean =&gt;</span>
<span class="hljs-addition">+ case t: Lit if config.isDisabled(t) =&gt;</span>
</code></pre>
<p>Congrats! The <code>NoLiteralArguments</code> linter is now configurable. Putting it
together, the final code looks like this</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// NoLiteralArguments.scala</span>
<span class="hljs-keyword">package</span> fix

<span class="hljs-keyword">import</span> metaconfig.<span class="hljs-type">Configured</span>
<span class="hljs-keyword">import</span> scala.meta._
<span class="hljs-keyword">import</span> scalafix.v1._

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiteralArgument</span>(<span class="hljs-params">literal: <span class="hljs-type">Lit</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Diagnostic</span> </span>{
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">position</span></span>: <span class="hljs-type">Position</span> = literal.pos
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">message</span></span>: <span class="hljs-type">String</span> =
    <span class="hljs-string">s"Use named arguments for literals such as 'parameterName = <span class="hljs-subst">$literal</span>'"</span>
}

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoLiteralArgumentsConfig</span>(<span class="hljs-params">
    disabledLiterals: <span class="hljs-type">List</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">List</span>("<span class="hljs-type">Boolean</span>"</span>)</span>
) {
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isDisabled</span></span>(lit: <span class="hljs-type">Lit</span>): <span class="hljs-type">Boolean</span> = {
    <span class="hljs-keyword">val</span> kind = lit.productPrefix.stripPrefix(<span class="hljs-string">"Lit."</span>)
    disabledLiterals.contains(kind)
  }
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">NoLiteralArgumentsConfig</span> </span>{
  <span class="hljs-keyword">val</span> <span class="hljs-keyword">default</span> = <span class="hljs-type">NoLiteralArgumentsConfig</span>()
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> surface =
    metaconfig.generic.deriveSurface[<span class="hljs-type">NoLiteralArgumentsConfig</span>]
  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">val</span> decoder =
    metaconfig.generic.deriveDecoder(<span class="hljs-keyword">default</span>)
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoLiteralArguments</span>(<span class="hljs-params">config: <span class="hljs-type">NoLiteralArgumentsConfig</span></span>)</span>
    <span class="hljs-keyword">extends</span> <span class="hljs-type">SyntacticRule</span>(<span class="hljs-string">"NoLiteralArguments"</span>) {
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">this</span></span>() = <span class="hljs-keyword">this</span>(<span class="hljs-type">NoLiteralArgumentsConfig</span>.<span class="hljs-keyword">default</span>)
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">withConfiguration</span></span>(config: <span class="hljs-type">Configuration</span>): <span class="hljs-type">Configured</span>[<span class="hljs-type">Rule</span>] = {
    config.conf
      .getOrElse(<span class="hljs-string">"NoLiteralArguments"</span>)(<span class="hljs-keyword">this</span>.config)
      .map(newConfig =&gt; <span class="hljs-keyword">new</span> <span class="hljs-type">NoLiteralArguments</span>(newConfig))
  }
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fix</span></span>(<span class="hljs-keyword">implicit</span> doc: <span class="hljs-type">SyntacticDocument</span>): <span class="hljs-type">Patch</span> = {
    doc.tree
      .collect {
        <span class="hljs-keyword">case</span> <span class="hljs-type">Term</span>.<span class="hljs-type">Apply</span>(_, args) =&gt;
          args.collect {
            <span class="hljs-keyword">case</span> t: <span class="hljs-type">Lit</span> <span class="hljs-keyword">if</span> config.isDisabled(t) =&gt;
              <span class="hljs-type">Patch</span>.lint(<span class="hljs-type">LiteralArgument</span>(t))
          }
      }
      .flatten
      .asPatch
  }
}
</code></pre>
<p>That completes the tutorial in implementing rules. Now let's run the rule on
real-world codebases.</p>
<p>There are two ways to run a custom rule: from source or from pre-compiled
artifacts.</p>
<h2><a class="anchor" aria-hidden="true" id="run-the-rule-from-source-code"></a><a href="#run-the-rule-from-source-code" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Run the rule from source code</h2>
<p>Running a rule from source code is the simplest way to run a custom rule.
However, rules that are compiled from source have the following limitations:</p>
<ul>
<li>Inflexible, rules must be implemented in a single source file</li>
<li>No dependencies, rules can only use the Scalafix public API</li>
<li>Slow, rule is re-compiled on every invocation so it's not great for
interactive usage.</li>
<li>No tab completion in the sbt shell, users need to manually type the path to
the source file</li>
</ul>
<p>The steps below assume you have scalafix setup according to the installation
instructions. The SemanticDB compiler plugin must be enabled to run semantic
rules like <code>NamedLiteralArguments</code>. Syntactic rules like the linter
<code>NoLiteralArguments</code> work without SemanticDB and don't require a <code>--classpath</code>
(when using the command-line interface).</p>
<p>You have different options to run the rule from source: <code>file:</code>, <code>http:</code> or
<code>github:</code></p>
<h3><a class="anchor" aria-hidden="true" id="using-file"></a><a href="#using-file" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using <code>file:</code></h3>
<p>If you have the source code for the rule on your local machine, you can run a
custom rule using the <code>file:/path/to/NamedLiteralArguments.scala</code> syntax.</p>
<pre><code class="hljs">scalafix --rules=file:/path/<span class="hljs-keyword">to</span>/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NamedLiteralArguments</span>.</span></span>scala
</code></pre>
<p>On Windows, the URI syntax is <code>file:///C:/Users/...</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="using-http"></a><a href="#using-http" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using <code>http:</code></h3>
<p>Another way to run a rule from source is to publish it as a gist and share the
raw URL</p>
<pre><code class="hljs">scalafix --rules=<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/gist.githubusercontent.com/olafurpg</span><span class="hljs-regexp">/eeccf32f035d13f0728bc94d8ec0a776/raw</span><span class="hljs-regexp">/78c81bb7f390eb98178dd26ea03c42bd5a998666/</span>NamedLiteralArguments.scala
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="using-github"></a><a href="#using-github" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using <code>github:</code></h3>
<p>Another way to run custom rules from source is to use the <code>github:org/repo</code>
scheme.</p>
<pre><code class="hljs"><span class="hljs-keyword">scalafix </span>--rules=github:<span class="hljs-keyword">scalacenter/named-literal-arguments
</span></code></pre>
<p>The expansion rules for <code>github:org/repo</code> are the following:</p>
<table>
<thead>
<tr><th>Before</th><th>After</th></tr>
</thead>
<tbody>
<tr><td><code>github:org/repo</code></td><td>(on <code>master</code>) <code>scalafix/rules/src/main/scala/fix/Repo.scala</code></td></tr>
<tr><td><code>github:org/some-repo</code></td><td>(on <code>master</code>) <code>scalafix/rules/src/main/scala/fix/SomeRepo.scala</code></td></tr>
<tr><td><code>github:org/repo/RuleName</code></td><td>(on <code>master</code>) <code>scalafix/rules/src/main/scala/fix/RuleName.scala</code></td></tr>
<tr><td><code>github:org/repo/com.example.RuleName</code></td><td>(on <code>master</code>) <code>scalafix/rules/src/main/scala/com/example/RuleName.scala</code></td></tr>
<tr><td><code>github:org/repo/RuleName?sha=main</code></td><td>(on <code>main</code>) <code>scalafix/rules/src/main/scala/fix/RuleName.scala</code></td></tr>
<tr><td><code>github:org/repo/RuleName?sha=HASH125</code></td><td>(at commit <code>HASH125</code>) <code>scalafix/rules/src/main/scala/fix/RuleName.scala</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="publish-the-rule-to-maven-central"></a><a href="#publish-the-rule-to-maven-central" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Publish the rule to Maven Central</h2>
<blockquote>
<p>If your rule only targets a single codebase and is not meant to be
distributed, you might want to develop it <a href="/scalafix/docs/developers/local-rules.html">as part of your existing
build</a> instead.</p>
</blockquote>
<p>Run the following sbt command to publish a rule locally.</p>
<pre><code class="hljs css language-sh">&gt; rules/publishLocal
</code></pre>
<p>To publish a rule online you need additional steps. First, add the settings
below to your <code>build.sbt</code> (replacing <code>ch.epfl.scala</code>, <code>scalacenter/scalafix</code> and
<code>olafurpg</code> with your own organization and project name)</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// build.sbt</span>
inThisBuild(<span class="hljs-type">List</span>(
  organization := <span class="hljs-string">"ch.epfl.scala"</span>,
  homepage := <span class="hljs-type">Some</span>(url(<span class="hljs-string">"https://github.com/scalacenter/scalafix"</span>)),
  licenses := <span class="hljs-type">List</span>(<span class="hljs-string">"Apache-2.0"</span> -&gt; url(<span class="hljs-string">"http://www.apache.org/licenses/LICENSE-2.0"</span>)),
  developers := <span class="hljs-type">List</span>(
    <span class="hljs-type">Developer</span>(
      <span class="hljs-string">"olafurpg"</span>,
      <span class="hljs-string">"Ólafur Páll Geirsson"</span>,
      <span class="hljs-string">"olafurpg@gmail.com"</span>,
      url(<span class="hljs-string">"https://geirsson.com"</span>)
    )
  )
))
</code></pre>
<p>Next, add the <code>sbt-ci-release</code> plugin to <code>project/plugins.sbt</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// project/plugins.sbt</span>
addSbtPlugin(<span class="hljs-string">"com.geirsson"</span> % <span class="hljs-string">"sbt-ci-release"</span> % <span class="hljs-string">"1.5.10"</span>)
</code></pre>
<p>If you have not setup GPG on your machine, run the following command</p>
<pre><code class="hljs css language-sh">gpg --gen-key
</code></pre>
<p>Finally, create a Sonatype account if you have never published to Sonatype
before. Follow the instructions
<a href="https://central.sonatype.org/pages/ossrh-guide.html">here</a>. If you don't have a
domain name, you can use <code>com.github.@username</code>. Here is a template you can use
to write the Sonatype issue:</p>
<pre><code class="hljs css language-text">Title:
Publish rights for com.github.olafurpg
Description:
Hi, I would like to publish under the groupId: com.github.olafurpg.
It's my GitHub account https://github.com/olafurpg/
</code></pre>
<p>Once Sonatype and GPG are setup, run the following command to publish the rule
online.</p>
<pre><code class="hljs css language-sh">&gt; rules/publishSigned
&gt; sonatypeRelease
</code></pre>
<p>Once published, users can run your rule with the following sbt command.</p>
<pre><code class="hljs css language-sh">// sbt shell
&gt; scalafix dependency:NamedLiteralArguments@ch.epfl.scala::named-literal-arguments:VERSION
</code></pre>
<p>To permanently install the rule for a build, users can add the dependency to
<code>build.sbt</code> by updating <code>ThisBuild / scalafixDependencies</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// build.sbt</span>
<span class="hljs-type">ThisBuild</span> / scalafixDependencies +=
  <span class="hljs-string">"ch.epfl.scala"</span> %% <span class="hljs-string">"named-literal-arguments"</span> % <span class="hljs-string">"VERSION"</span>
<span class="hljs-comment">// sbt shell</span>
&gt; scalafix <span class="hljs-type">NamedLiteralArguments</span>
</code></pre>
<p>For builds using <code>project/*.scala</code> files, add the following auto import</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scalafix.sbt.<span class="hljs-type">ScalafixPlugin</span>.autoImport._
</code></pre>
<p>Users of the Scalafix command-line interface can use the <code>--tool-classpath</code> flag</p>
<pre><code class="hljs">scalafix \
  --tool-classpath <span class="hljs-constructor">$(<span class="hljs-params">cs</span> <span class="hljs-params">fetch</span> <span class="hljs-params">ch</span>.<span class="hljs-params">epfl</span>.<span class="hljs-params">scala</span>::<span class="hljs-params">named</span>-<span class="hljs-params">literal</span>-<span class="hljs-params">arguments</span>:<span class="hljs-params">latest</span>.<span class="hljs-params">release</span> -<span class="hljs-params">p</span>)</span> \
  -r NamedLiteralArguments \
  --classpath MY_PROJECT_CLASSPATH \
  my-project/src/main/scala
</code></pre>
<p>Note that for syntactic rules like <code>NoLiteralArguments</code>, the <code>--classpath</code>
argument is not required.</p>
<h3><a class="anchor" aria-hidden="true" id="adding-custom-resolver"></a><a href="#adding-custom-resolver" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adding custom resolver</h3>
<p>Update the <code>scalafixResolvers</code> setting to resolve rules that are published to a
custom repository like Bintray or a private Nexus.</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// build.sbt</span>
<span class="hljs-type">ThisBuild</span> / scalafixResolvers ++= <span class="hljs-type">List</span>(
  coursierapi.<span class="hljs-type">MavenRepository</span>.of(<span class="hljs-string">"https://central.sonatype.com/repository/maven-snapshots/"</span>),
  coursierapi.<span class="hljs-type">IvyRepository</span>.of(<span class="hljs-string">"https://foo.com/a/b/c/[defaultPattern]"</span>)
)
</code></pre>
<p>Notice for Ivy resolvers, <code>coursierapi.IvyRepository.of</code> is interpolated as a pattern. Appending <code>[defaultPattern]</code>
uses this <a href="https://github.com/coursier/coursier/blob/a92e4f263f494199078adfb1c5db67ba0b076674/modules/core/shared/src/main/scala/coursier/ivy/Pattern.scala#L107">convenience method</a>
to substitute in <a href="https://github.com/coursier/coursier/blob/a92e4f263f494199078adfb1c5db67ba0b076674/modules/core/shared/src/main/scala/coursier/ivy/Pattern.scala#L236-L245">this default pattern</a>.
Tests showing a working example can found <a href="https://github.com/coursier/coursier/blob/master/modules/tests/jvm/src/test/scala/coursier/test/IvyTests.scala">here</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="conclusion"></a><a href="#conclusion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h3>
<p>Don't be intimidated by publishing to Maven Central, it gets easier once you've
done it the first time. A more detailed guide on how to publish libraries can be
found <a href="https://github.com/olafurpg/sbt-ci-release">here</a>. The benefits of
publishing a rule to Maven Central are many.</p>
<ul>
<li>Bring your own dependencies, you can use custom library dependency to
implement a published rule.</li>
<li>Fast to run, no need to re-compile the rule on every Scalafix invocation.</li>
<li>Tab completion in sbt, users can tab-complete your rule when using sbt plugin.</li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/scalafix/docs/developers/before-you-begin.html"><span class="arrow-prev">← </span><span>Before you write code</span></a><a class="docs-next button" href="/scalafix/docs/developers/local-rules.html"><span>Local rules</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#import-the-build">Import the build</a></li><li><a href="#write-unit-tests">Write unit tests</a></li><li><a href="#use-pattern-matching-to-find-interesting-tree-nodes">Use pattern matching to find interesting tree nodes</a></li><li><a href="#use-symbolinformation-to-lookup-method-signatures">Use <code>SymbolInformation</code> to lookup method signatures</a></li><li><a href="#use-diagnostic-to-report-linter-errors">Use <code>Diagnostic</code> to report linter errors</a></li><li><a href="#use-withconfiguration-to-make-a-rule-configurable">Use <code>withConfiguration</code> to make a rule configurable</a></li><li><a href="#run-the-rule-from-source-code">Run the rule from source code</a><ul class="toc-headings"><li><a href="#using-file">Using <code>file:</code></a></li><li><a href="#using-http">Using <code>http:</code></a></li><li><a href="#using-github">Using <code>github:</code></a></li></ul></li><li><a href="#publish-the-rule-to-maven-central">Publish the rule to Maven Central</a><ul class="toc-headings"><li><a href="#adding-custom-resolver">Adding custom resolver</a></li><li><a href="#conclusion">Conclusion</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer" style="background-color:#15242B"><section class="sitemap"><a href="/scalafix/" class="nav-home"><img src="/scalafix/img/scalafix-brand-small2x.png" alt="Scalafix" width="52" height="52"/></a><div><h5>Docs</h5><a href="
                /scalafix/docs/users/installation.html">Get started</a><a href="
                /scalafix/docs/rules/overview.html">Rules</a><a href="
                /scalafix/docs/developers/setup.html">Extend Scalafix</a></div><div><h5>Community</h5><a href="https://discord.gg/8AHaqGx3Qj" target="_blank">Chat on Discord</a><a href="https://users.scala-lang.org/" target="_blank">Discuss on Scala Users</a></div><div><h5>More</h5><a href="https://github.com/scalacenter/scalafix" target="_blank">GitHub</a></div></section><section class="copyright">Copyright © 2025 Scala Center</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'cf575cebacff15579dd2dee010c4010f',
                indexName: 'scalafix',
                inputSelector: '#search_input_react'
              });
            </script></body></html>