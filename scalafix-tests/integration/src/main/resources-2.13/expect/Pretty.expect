[7:7..7:17]:      test/PrettyTest# => class PrettyTest extends AnyRef { +4 decls }
[7:18..7:18]:     test/PrettyTest#`<init>`(). => primary ctor <init>()
[8:3..8:14]:      *[Int]
[8:3..8:7]:       *.apply[Int]
[9:3..13:12]:     orig(1.to(10)).flatMap[Int](
                    { (i) =>
                      orig(2.to(20)).withFilter(
                        { (j) => orig(i > i) }
                      ).map[Int]({ (j) => orig(j) })
                    }
                  )
[10:10..10:11]:   intWrapper(*)
[11:10..11:11]:   intWrapper(*)
[14:3..18:15]:    orig(Future(1.to(10)))(global).foreach[Unit](
                    { (i) =>
                      orig(Future(2.to(i.length)))(global).foreach[Unit](
                        { (j) => orig(println(j)) }
                      )(global)
                    }
                  )(global)
[15:10..15:16]:   *.apply[Inclusive]
[15:17..15:18]:   intWrapper(*)
[16:10..16:16]:   *.apply[Inclusive]
[16:17..16:18]:   intWrapper(*)
[21:9..21:14]:    test/PrettyTest#Inner# => class Inner extends AnyRef { +1 decls }
[21:14..21:14]:   test/PrettyTest#Inner#`<init>`(). => primary ctor <init>()
[22:7..22:8]:     test/PrettyTest#a. => val method a: PrettyTest
[23:7..23:8]:     test/PrettyTest#b. => val method b: a.Inner
[25:3..25:9]:     *.apply[AnyRef {
                    local4 => abstract method bar(a: Int): Int
                    local6 => abstract method foo(a: Int): Int
                  }]
[29:3..29:9]:     *.apply[a.Inner]
[30:3..30:9]:     *.apply[Int with String {}]
[31:3..31:9]:     *.apply[PrettyTest]
[38:7..38:10]:    test/ann# => class ann[T] extends Annotation with StaticAnnotation { +2 decls }
[38:11..38:12]:   test/ann#[T] => typeparam T
[38:13..38:13]:   test/ann#`<init>`(). => primary ctor <init>(x: T)
[38:14..38:15]:   test/ann#x. => private[this] val method x: T
[39:7..39:11]:    test/ann1# => class ann1 extends Annotation with StaticAnnotation { +1 decls }
[39:12..39:12]:   test/ann1#`<init>`(). => primary ctor <init>()
[40:7..40:11]:    test/ann2# => class ann2 extends Annotation with StaticAnnotation { +1 decls }
[40:12..40:12]:   test/ann2#`<init>`(). => primary ctor <init>()
[42:7..42:8]:     test/B# => class B extends AnyRef { +1 decls }
[42:8..42:8]:     test/B#`<init>`(). => primary ctor <init>()
[44:7..44:8]:     test/C# => class C extends AnyRef { +1 decls }
[44:8..44:8]:     test/C#`<init>`(). => primary ctor <init>()
[46:7..46:8]:     test/P# => class P extends AnyRef { +4 decls }
[46:9..46:9]:     test/P#`<init>`(). => primary ctor <init>()
[47:9..47:10]:    test/P#C# => class C extends AnyRef { +1 decls }
[47:10..47:10]:   test/P#C#`<init>`(). => primary ctor <init>()
[48:9..48:10]:    test/P#X# => class X extends AnyRef { +1 decls }
[48:10..48:10]:   test/P#X#`<init>`(). => primary ctor <init>()
[49:7..49:8]:     test/P#x. => val method x: X
[52:7..52:8]:     test/T# => class T extends AnyRef { +4 decls }
[52:9..52:9]:     test/T#`<init>`(). => primary ctor <init>()
[53:9..53:10]:    test/T#C# => class C extends AnyRef { +1 decls }
[53:10..53:10]:   test/T#C#`<init>`(). => primary ctor <init>()
[54:9..54:10]:    test/T#X# => class X extends AnyRef { +1 decls }
[54:10..54:10]:   test/T#X#`<init>`(). => primary ctor <init>()
[55:7..55:8]:     test/T#x. => val method x: X
[58:8..58:12]:    test/Test. => final object Test extends AnyRef { +4 decls }
[59:9..59:10]:    test/Test.M# => class M extends AnyRef { +2 decls }
[59:11..59:11]:   test/Test.M#`<init>`(). => primary ctor <init>()
[60:9..60:10]:    test/Test.M#m(). => method m: Int
[63:9..63:10]:    test/Test.N# => trait N extends AnyRef { +1 decls }
[64:9..64:10]:    test/Test.N#n(). => method n: Int
[67:9..67:10]:    test/Test.C# => class C extends M { +35 decls }
[67:11..67:11]:   test/Test.C#`<init>`(). => primary ctor <init>()
[68:9..68:10]:    test/Test.C#p. => val method p: P
[69:9..69:10]:    test/Test.C#x. => val method x: p.X
[71:9..71:17]:    test/Test.C#typeRef1. => val method typeRef1: C
[72:9..72:17]:    test/Test.C#typeRef2. => val method typeRef2: p.C
[73:9..73:17]:    test/Test.C#typeRef3. => val method typeRef3: T#C
[74:9..74:17]:    test/Test.C#typeRef4. => val method typeRef4: List[Int]
[76:9..76:20]:    test/Test.C#singleType1. => val method singleType1: x.type
[77:9..77:20]:    test/Test.C#singleType2. => val method singleType2: p.x.type
[78:9..78:15]:    test/Test.C#Either. => val method Either: Either.type
[80:9..80:18]:    test/Test.C#thisType1. => val method thisType1: C.this.type
[81:9..81:18]:    test/Test.C#thisType2. => val method thisType2: C.this.type
[83:9..83:19]:    test/Test.C#superType1. => val method superType1: Int
[84:9..84:19]:    test/Test.C#superType2. => val method superType2: Int
[85:9..85:19]:    test/Test.C#superType3. => val method superType3: Int
[87:9..87:22]:    test/Test.C#compoundType1. => val method compoundType1: AnyRef { def k: Int }
[88:9..88:22]:    test/Test.C#compoundType2. => val method compoundType2: M with N {}
[89:9..89:22]:    test/Test.C#compoundType3. => val method compoundType3: M with N { def k: Int }
[90:9..90:22]:    test/Test.C#compoundType4. => val method compoundType4: AnyRef { def k: Int }
[91:9..91:22]:    test/Test.C#compoundType5. => val method compoundType5: M with N {}
[92:9..92:22]:    test/Test.C#compoundType6. => val method compoundType6: M with N { def k: Int }
[94:9..94:17]:    test/Test.C#annType1. => val method annType1: T @ann[Int]
[95:9..95:17]:    test/Test.C#annType2. => val method annType2: T @ann1 @ann2
[97:9..97:25]:    test/Test.C#existentialType2. => val method existentialType2: List[_] forSome { type _ }
[98:9..98:25]:    test/Test.C#existentialType3. => val method existentialType3: Class[?0] forSome { type ?0 }
[99:9..99:25]:    test/Test.C#existentialType4. => val method existentialType4: Class[?0] forSome { type ?0 }
[101:9..101:20]:  test/Test.C#typeLambda1(). => method typeLambda1[M[_]]: Nothing
[101:21..101:22]: test/Test.C#typeLambda1().[M] => typeparam M[_]
[104:12..104:26]: test/Test.C#ClassInfoType1. => final object ClassInfoType1 extends AnyRef
[105:11..105:25]: test/Test.C#ClassInfoType2# => class ClassInfoType2 extends B { +2 decls }
[105:26..105:26]: test/Test.C#ClassInfoType2#`<init>`(). => primary ctor <init>()
[105:42..105:43]: test/Test.C#ClassInfoType2#x(). => method x: Int
[106:11..106:25]: test/Test.C#ClassInfoType3# => trait ClassInfoType3[T] extends AnyRef
[106:26..106:27]: test/Test.C#ClassInfoType3#[T] => typeparam T
[108:12..108:22]: test/Test.C#MethodType. => final object MethodType extends AnyRef { +6 decls }
[109:11..109:13]: test/Test.C#MethodType.x1(). => method x1: Int
[110:11..110:13]: test/Test.C#MethodType.x2(). => method x2: Int
[111:11..111:13]: test/Test.C#MethodType.m3(). => method m3: Int
[112:11..112:13]: test/Test.C#MethodType.m4(). => method m4(): Int
[113:11..113:13]: test/Test.C#MethodType.m5(). => method m5(x: Int): Int
[113:14..113:15]: test/Test.C#MethodType.m5().(x) => param x: Int
[114:11..114:13]: test/Test.C#MethodType.m6(). => method m6[T](x: T): T
[114:14..114:15]: test/Test.C#MethodType.m6().[T] => typeparam T
[114:17..114:18]: test/Test.C#MethodType.m6().(x) => param x: T
[117:12..117:22]: test/Test.C#ByNameType. => final object ByNameType extends AnyRef { +1 decls }
[118:11..118:13]: test/Test.C#ByNameType.m1(). => method m1(x: => Int): Int
[118:14..118:15]: test/Test.C#ByNameType.m1().(x) => param x: => Int
[121:16..121:28]: test/Test.C#RepeatedType# => case class RepeatedType extends AnyRef with Product with Serializable { +12 decls }
[121:28..121:28]: test/Test.C#RepeatedType#`<init>`(). => primary ctor <init>(val s: String*)
[121:29..121:30]: test/Test.C#RepeatedType#s. => val method s: String*
[122:11..122:13]: test/Test.C#RepeatedType#m1(). => method m1(x: Int*): Int
[122:14..122:15]: test/Test.C#RepeatedType#m1().(x) => param x: Int*
[125:12..125:20]: test/Test.C#TypeType. => final object TypeType extends AnyRef { +5 decls }
[126:12..126:14]: test/Test.C#TypeType.T1# => abstract type T1
[127:11..127:13]: test/Test.C#TypeType.m2(). => method m2[T2 = C]: Nothing
[127:14..127:16]: test/Test.C#TypeType.m2().[T2] => typeparam T2 = C
[128:11..128:13]: test/Test.C#TypeType.m3(). => method m3[M3[_]]: Nothing
[128:14..128:16]: test/Test.C#TypeType.m3().[M3] => typeparam M3[_]
[129:12..129:14]: test/Test.C#TypeType.T4# => type T4 = C
[130:12..130:14]: test/Test.C#TypeType.T5# => type T5[U] = U
[130:15..130:16]: test/Test.C#TypeType.T5#[U] => typeparam U
[134:10..134:17]: test/Test.Literal. => final object Literal extends AnyRef { +11 decls }
[135:15..135:18]: test/Test.Literal.int. => final val method int: 1
[136:15..136:19]: test/Test.Literal.long. => final val method long: 1L
[137:15..137:20]: test/Test.Literal.float. => final val method float: 1.0f
[138:15..138:21]: test/Test.Literal.double. => final val method double: 2.0
[139:15..139:18]: test/Test.Literal.nil. => final val method nil: null
[140:15..140:19]: test/Test.Literal.char. => final val method char: 'a'
[141:15..141:21]: test/Test.Literal.string. => final val method string: "a"
[142:15..142:19]: test/Test.Literal.bool. => final val method bool: true
[143:15..143:19]: test/Test.Literal.unit. => final val method unit: Unit
[144:15..144:23]: test/Test.Literal.javaEnum. => final val method javaEnum: NOFOLLOW_LINKS.type
[145:15..145:22]: test/Test.Literal.clazzOf. => final val method clazzOf: Class[Option[Int]]